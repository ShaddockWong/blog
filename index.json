
[{"content":" 创造者模式概述 # 建造者模式可以将部分本身和它们得组装过程分开，关注如何一步一步地创建一个包含多个组成部分得复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无需知道其内部的具体构造细节。\n建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\nBuilder Pattern: Separate the construction of a complex object from its representation so that the same construction process can create different representations.\n建造者模式结构 # 建造者模式的结构如下图所示：\n建造者模式结构图 由上图可知，建造者模式包含以下 4 个角色。\nBuilder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是 buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是 getResult()，它们用于返回复杂对象。Builder 既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了 Builder 接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。 Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装备过程。 Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其 construct() 建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制实现），然后通过指挥者类的构造函数或者 Setter 方法将该对象传入指挥者类中。 建造者模式实现 # 在建造者模式的定义中提到了复杂对象，那什么是复杂对象呢？简单来说，复杂对象是指那些包含多个成员变量的对象，这些成员变量也称为部件或零件。一个典型的复杂对象类的代码示例如下：\npublic class Product { private String partA; // 定义部件，部件可以是任意类型，包括值类型和引用类型 private String partB; private String partC; // partA的Getter方法和Setter方法省略 // partB的Getter方法和Setter方法省略 // partC的Getter方法和Setter方法省略 } 在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：\npublic abstract class Builder { // 创建产品对象 protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); // 返回产品对象 public Product getResult() { return product; } } 在抽象类 Builder 中声明了一系列抽象的 buildPartX() 方法，用于创建复杂产品的各个部件，具体创造过程在 ConcreteBuilder 中实现，此外还提供了工厂方法 getResult()，用于返回一个已创建好的完整产品对象。\n在 ConcreteBuilder 中实现了这些 buildPartX() 方法，通过调用 Product 的 setPartX() 方法可以给产品对象的成员变量设值，不同的具体建造者在实现 buildPartX() 方法时有所区别，例如 setPartX() 方法的参数可能不一样，在有些具体建造者类中某些 setPartX() 方法无需实现（提供一个空实现）。而这些对于客户端来说都无需关心，客户端只需知道具体建造者类型即可。典型的具体建造者类代码如下：\npublic class ConcreteBuilder1 extends Builder { public void buildPartA() { product.setPartA(\u0026#34;A1\u0026#34;); } public void buildPartB() { product.setPartB(\u0026#34;B1\u0026#34;); } public void buildPartC() { product.setPartC(\u0026#34;C1\u0026#34;); } } 此外，在建造者模式中还引入了一个指挥者类 Director，该类主要有两个作用：一方面它隔离了客户端与创建过程；另一方面它控制产品对象的创建过程，包括某个 buildPartX() 方法是个被调用以及多个 buildPartX() 方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型便可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。指挥者的示例代码如下：\npublic class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void setBuilder(Builder builder) { this.builder = builder; } // 产品构建和组装方法 public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } 在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法 construct()，在该方法中调用了 builder 对象的构造部件的方法，最后返回一个产品对象。\n对于客户端而言，只需要关心具体建造者的类型，无需关心产品对象的具体组装过程。通常，客户类代码片段如下：\n... Builder builder = new ConcreteBuilder1(); // 可通过配置文件实现 Director director = new Director(builder); Product product = director.construct(); ... 可以通过配置文件来存储具体建造者类 ConcreteBuilder1 的类名，使得在更换新的建造者时无需修改源代码，系统扩展更方便。\n建造者模式与抽象工厂模式都是较为复杂的创建型模式，建造者模式返回一个完整的复杂产品，抽象工厂模式返回一系列相关的产品；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型来指导 Director 类如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个骑车配件生产厂，生成不同类型的骑车配件，那么建造者模式就是一个骑车组装常，通过对配件进行组装返回一辆完整的汽车。\n建造者模式应用实例 # 实例说明 # 某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。\n作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、脸型等多个组成部分，不同类型的游戏角色，其性别、脸型、服装、发型等外部特征都有所差异，例如“天使”拥有着美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”及其丑陋，留着光头并穿着一件刺眼的黑衣。\n无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。\n试使用建造者模式来实现游戏角色的创建。\n实例类图 # 通过分析，本实例的结构如图所示：\n游戏角色创建结构图 实例代码 # Actor：游戏角色类，充当复杂产品对象。考虑到代码的可读性，在此只列出部分成员变量，且成员变量的类型均为 String，在真实情况下，有些成员变量的类型需要自定义。\npublic class Actor { private String type; // 角色类型 private String sex; // 性别 private String face; // 脸型 private String costume; // 服装 private String hairstyle; // 发型 public void setType(String type){ this.type = type; } public void setFace(String face){ this.face = face; } public void setSex(String sex) { this.sex = sex; } public void setCostume(String costume){ this.costume = costume; } public void setHairstyle(String hairstyle) { this.hairstyle = hairstyle; } public String getType() { return type; } public String getSex() { return sex; } public String getFace() { return face; } public String getCostume() { return costume; } public String getHairstyle() { return hairstyle; } } ActorBuilder：游戏角色创建者，充当抽象建造者。\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 工厂方法，返回一个完整的游戏角色对象 public Actor createActor() { return actor; } } HeroBuilder：英雄角色建造者，充当具体建造者。\npublic class HeroBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;英雄\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;男\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;英俊\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;盔甲\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;飘逸\u0026#34;); } } AngleBuilder：天使角色建造者，充当具体建造者。\npublic class AngleBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;天使\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;女\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;漂亮\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;白裙\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;披肩长发\u0026#34;); } } DevilBuilder：恶魔角色建造者，充当具体建造者。\npublic class DevilBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;恶魔\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;妖\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;丑陋\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;黑衣\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;光头\u0026#34;); } } ActorController：角色控制器，充当指挥者。\npublic class ActorController { // 逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); actor = ab.createActor(); return actor; } } 配置文件 config.xml，在配置文件中存储了具体建造者类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.builder.AngleBuilder\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\n// 将 XML 工具类提取到 utils 包中，传入config.xml 文件路径，方便使用 package com.wangyq.utils; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import java.io.File; public class XMLUtil { public static Object getBean(String filePath) { try { // 创建 DOM 文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(filePath)); // 获取包含类名的文本结点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { ActorBuilder ab; // 针对抽象建造者编程 ab = (ActorBuilder) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/builder/config.xml\u0026#34;); // 反射生成具体建造者对象 ActorController ac = new ActorController(); Actor actor; actor = ac.construct(ab); // 通过指挥者创建完整的建造者对象 String type = actor.getType(); System.out.println(type + \u0026#34;的外观：\u0026#34;); System.out.println(\u0026#34;性别：\u0026#34; + actor.getSex()); System.out.println(\u0026#34;面容：\u0026#34; + actor.getFace()); System.out.println(\u0026#34;服装：\u0026#34; + actor.getCostume()); System.out.println(\u0026#34;发型：\u0026#34; + actor.getHairstyle()); } } 结果及分析 # 编译并运行程序，输出结果如下：\n天使的外观： 性别：女 面容：漂亮 服装：白裙 发型：披肩长发 如果需要更换具体角色建造者，只需要修改配置文件即可。\n当需要增加新的具体角色建造者时只需要将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件，原有代码无需修改，完全符合开闭原则。\n指挥者类的深入讨论 # 指挥者类 Director 是建造者模式的重要组成部分，简单的 Director 类用于指导具体建造者如何构建产品，它按一定次序调用 Builder 的 buildPartX() 的方法，控制调用的先后次序，并向客户端返回一个完整的产品对象。下面讨论几种 Director 的变化形式。\n省略 Director # 在有些情况下，为了简化系统结构，可以将 Director 和抽象建造者 Builder 进行合并，在 Builder 中提供逐步构建复杂产品对象的 construct() 方法。由于 Builder 类通常为抽象类，因此可以将 construct() 方法定义为静态（static）方法，以便客户端能够直接调用。如果将游戏角色实例中的指挥者类 ActorController 省略，ActorBuilder 类的代码修改如下：\npublic abstract class ActorBuilder { protected static Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public static Actor construct(ActorBuilder ab) { ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); return actor; } } 此时对应的客户端代码也将发生修改，代码片段如下：\n... ActorBuilder ab; ab = (ActorBuilder) XMLUtil.getBean(); Actor actor; actor = ActorBuilder.construct(ab); ... 除此之外，还有一种更简单的处理方式，可以将 construct() 方法中的参数去掉，直接在 construct() 方法中调用 buildPartX() 方法，代码如下：\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public Actor construct() { this.buildType(); this.buildSex(); this.buildFace(); this.buildCostume(); this.buildHairstyle(); return actor; } } 客户端代码片段如下：\n... ActorBuilder ab; ab = (ActorBuilder) XMLUtil.getBean(); Actor actor; actor = ab.construct(); ... 此时，construct() 方法定义了 buildPartX() 方法的调用次序，为 buildPartX() 方法的执行提供了一个流程模板，这与在后边要学习的模板方法非常类似。\n以上两种对 Director 类的省略方法都不影响系统的灵活性和可扩展性，同时还简化了系统结构，但加重了抽象建造者类的职责。如果 construct() 方法较为复杂，待构建产品的组成部分比较多，建议还是将 construct() 方法单独封装在 Director 中，这样更符合单一职责原则。\n钩子方法的引入 # 钩子方法（Hook Method）用来控制是否对某个 buildPartX() 进行调用。\n钩子方法的返回类型通常为 boolean 类型，方法名一般为 isXXX()，钩子方法定义在抽象建造者类中。例如可以在游戏角色的抽象建造者类 ActorBuilder 中定义一个方法 isBareheaded()，用于判断某个角色是否为“光头（Bareheaded）”，在 ActorBuilder 为之提供一个默认实现，代码如下：\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 钩子方法 public boolean isBareheaded() { return false; } public Actor createActor() { return actor; } } 如果某个角色无需构建头发部件，例如“恶魔”，则对应的具体建造器 DevilBuilder 将覆盖 isBareheaded() 方法，并将返回值改为 true，代码如下：\npublic class DevilBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;恶魔\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;妖\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;丑陋\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;黑衣\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;光头\u0026#34;); } // 覆盖钩子方法 public boolean isBareheaded() { return true; } } 同时，指挥者类 ActorController 的代码修改如下：\npublic class ActorController { // 逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); // 通过钩子方法来控制产品的构建 if(!ab.isBareHeaded()) { ab.buildHairstyle(); } actor = ab.createActor(); return actor; } } 当在客户端代码中置顶具体建造者类型并通过指挥者来实现产品的逐步构建时，将调用钩子方法 isBareheaded() 来判断游戏角色是否有头发，如果 isBareheaded() 方法返回 true，即没有头发，将跳过构建发型的方法 buildHairstyle()，否则将执行 buildHairstyle() 方法。\n通过引入钩子方法，可以在 Director 中对复杂产品的构建进行精细的控制，不仅指定 buildPartX() 方法的执行顺序，还可以控制是否需要执行某个 buildPartX() 方法。\n建造者模式优点： # 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因为可以很方便地替换具体建造者或增加新的具体建造，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。 建造者模式缺点： # 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。 建造者模式适用环境 # 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类将创建过程封装在指挥者类中，而不在建造者和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 ","date":"2024-7-12","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater06/","section":"Posts","summary":"","title":"06-建造者模式","type":"posts"},{"content":"","date":"2024-7-12","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024-7-12","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2024-7-12","externalUrl":null,"permalink":"/categories/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Categories","summary":"","title":"Java设计模式","type":"categories"},{"content":"","date":"2024-7-12","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-7-12","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"弱小和无知不是生存的障碍，傲慢才是。\n三体\n","date":"2024-7-12","externalUrl":null,"permalink":"/","section":"你应该看不见我吧","summary":"","title":"你应该看不见我吧","type":"page"},{"content":"","date":"2024-7-12","externalUrl":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"设计模式","type":"tags"},{"content":" 产品等级结构和产品族 # 工厂方法模式通过引入工厂等级结构解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个具体工厂只有一个或者一组重载的工厂方法，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。有时候可能需要一个工厂可以提供多种产品对象，而不是单一的产品对象，此时可以考虑将一些相关的产品组成一个“产品族”，由一个工厂来统一生产。\n为了更好地理解抽象工厂模式，先引入两个概念：\n产品等级结构：产品等级结构即产品的继承结构。 产品族：在抽象工厂模式中，产品族是指由同一工厂生产的位于不同产品等级结构中的一组产品。 产品等级结构和产品族示意图如下图所示：\n产品族与产品等级结构示意图 在上图中一共包含了 3 个产品族，分属于 3 个不同的产品等级结构，只要指明一个产品所处的产品族以及它所属的等级结构就可以唯一确定这个产品。\n抽象工厂模式概述 # 当系统所提供的工厂生产的具体产品不是一个见到那的对象，而是多个不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。\n抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构的一个产品族中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如下图所示：\n抽象工厂模式示意图 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。\n抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\nAbstract Factory Pattern: Provide an interface for creating familes of related or dependent objects without specifying their concrete classes.\n抽象工厂模式又称为工具（Kit）模式，它是一种对象创建型模式。\n抽象工厂模式结构 # 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图所示：\n抽象工厂模式结构图 由上图可知，抽象工厂模式包含以下 4 个角色：\nAbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生产一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 抽象工厂模式实现 # 在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以时接口，也可以是抽象类或者具体类。其典型代码如下：\npublic interface AbstractFactory { public AbstractProductA createProductA(); // 工厂方法一 public AbstractProductB createProductB(); // 工厂方法二 } 具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下：\npublic class ConcreteFactory1 extends AbstractFactory { // 工厂方法一 public AbstractProductA createProductA() { return new ConcreteProductA1(); } // 工厂方法二 public AbstractProductB createProductB() { return new ConcreteProductB1(); } } 与工厂方法模式一样，抽象工厂模式也可以为每一种产品提供一组重载的工厂方法，以不同的方式来创建产品对象。\n抽象工厂模式应用实例 # 实例说明 # 某软件公司要开发一套界面皮肤库，可以对基于 Java 的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天（Spring）风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天（Summer）风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：\n界面皮肤库结构示意图 该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。\n实力类图 # 通过分析，本实例的结构图如下图所示：\n实例代码 # Button：按钮接口，充当抽象产品。\npublic interface Button { public void display(); } SpringButton：Spring 按钮类，充当具体产品。\npublic class SpringButton implements Button{ @Override public void display() { System.out.println(\u0026#34;显示浅绿色按钮。\u0026#34;); } } SummerButton：Summer 按钮类，充当具体产品。\npublic class SummerButton implements Button { @Override public void display() { System.out.println(\u0026#34;显示浅蓝色按钮。\u0026#34;); } } TextField：文本框接口，充当抽象产品。\npublic interface TextField { public void display(); } SpringTextField：Spring 文本框类，充当具体产品。\npublic class SpringTextField implements TextField{ @Override public void display() { System.out.println(\u0026#34;显示绿色边框文本框。\u0026#34;); } } SummerTextField：Summer 文本框类，充当具体产品。\npublic class SummerTextField implements TextField{ @Override public void display() { System.out.println(\u0026#34;显示蓝色边框文本。\u0026#34;); } } ComboBox：组合框接口，充当抽象产品。\npublic interface ComboBox { public void display(); } SpringComboBox：Spring 组合框类，充当具体产品。\npublic class SpringComboBox implements ComboBox{ @Override public void display() { System.out.println(\u0026#34;显示绿色边框组合框。\u0026#34;); } } SummerComboBox：Summer 组合框类，充当具体产品。\npublic class SummerComboBox implements ComboBox{ @Override public void display() { System.out.println(\u0026#34;显示蓝色边框组合框。\u0026#34;); } } SkinFactory：界面皮肤工厂接口，充当抽象工厂。\npublic interface SkinFactory { public Button createButton(); public TextField createTextField(); public ComboBox createComboBox(); } SpringSkinFactory：Spring 皮肤工厂，充当具体工厂。\npublic class SpringSkinFactory implements SkinFactory{ @Override public Button createButton() { return new SpringButton(); } @Override public TextField createTextField() { return new SpringTextField(); } @Override public ComboBox createComboBox() { return new SpringComboBox(); } } SummerSkinFactory：Summer 皮肤工厂，充当具体工厂。\npublic class SummerSkinFactory implements SkinFactory { @Override public Button createButton() { return new SummerButton(); } @Override public TextField createTextField() { return new SummerTextField(); } @Override public ComboBox createComboBox() { return new SummerComboBox(); } } 配置文件 config.xml，在配置文件中存储了具体工厂类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.abstractfactory.SpringSkinFactory\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\npublic class XMLUtil { //该方法用于从XML配置文件中提取具体类类名， 并返回一个实例对象 public static Object getBean() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/abstractfactory/config.xml\u0026#34;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { // 使用抽象层定义 SkinFactory factory; Button bt; TextField tf; ComboBox cb; factory = (SkinFactory) XMLUtil.getBean(); bt = factory.createButton(); tf = factory.createTextField(); cb = factory.createComboBox(); bt.display(); tf.display(); cb.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n显示浅绿色按钮。 显示绿色边框文本框。 显示绿色边框组合框。 如果需要更换皮肤，只需要修改配置文件即可。\n如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件中的具体工厂类名即可使用新的皮肤，原有代码无需修改，符合开闭原则。\n开闭原则的倾斜性 # 在抽象工厂模式中增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。开闭原则要求对扩展开放，对修改关闭，通过扩展达到增强其功能的目的，对于涉及多个产品族与多个产品等级结构的系统，其功能增强包括两个方面。\n增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无需做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，它以一种倾斜的方式来满足开闭原则，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够考虑全面，不会在设计完成之后再向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n抽象工厂模式优/缺点与使用环境 # 抽象工厂模式是工厂方法模式的进一步眼神，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和 API 类库的设计中。\n抽象工厂模式优点 # 抽象工厂模式隔离了具体类的生产，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对榕溪，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无需修改已有系统，符合开闭原则。 抽象工厂模式缺点 # 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不变，违背了开闭原则。\n抽象工厂模式适用环境 # 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无需关系对象的创建过程，将对象的创建和使用解耦。 系统中有多于一个的产品族，而每次只是用其中某一产品族。可以通过配置文件等方式来使用户能够动态改变产品族，也可以很方便地增加新的产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 ","date":"2024-7-10","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater05/","section":"Posts","summary":"","title":"05-抽象工厂模式","type":"posts"},{"content":" 工厂方法模式概述 # 简单工厂模式在新增一个类型时，需要修改工厂类的代码，使得整个设计在一定程度上违反了开闭原则。工厂方法模式通过引入抽象的工厂类，使得它在新增类型时不需要修改具体的工厂类就可以创建，让系统更加符合开闭原则。\n在工厂方法模式中不再提供一个同一个的工厂类来创建所有的产品对象，二是针对不同的产品提供不同的工厂，系统提供一个与产品等级接口对应的工厂等级结构。\n工厂方法模式：定义一个用于创建实例对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。\nFactory Method Pattern: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n工厂方法模式简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。工厂方法模式时一种类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n工厂方法模式结构 # 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。结构图如下所示：\n工厂方法模式结构图 由上图可知，工厂方法模式包含以下 4 个角色：\nProduct（抽象产品）：它时定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品一一对应。 Factory（抽象工厂）：在抽象工厂类中声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 工厂方法模式实现 # 与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下：\npublic interface Factory { public Product factoryMethod(); } 在抽象工厂中声明了工厂方法单并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。其典型代码如下：\npublic class ConcreteFactory implement Factory { public Product factoryMethod() { return new ConcreteProduct(); } } 在实际使用时，具体工厂类在实现工厂方法时处理创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件都能。\n在客户端代码中，开发人员只需关心工厂类接口，不同的具体工厂可以创建不同的产品。典型的客户端代码片段如下：\n... Factory factory; factory = new ConcreteFactory(); // 可通过配置文件与反射机制实现 Product product; product = factory.factoryMethod(); ... 可以通过配置文件来存储具体工厂类 ConcreteFactory 的类名，再通过反射机制创建具体工厂对象，在更换新的具体工厂时无需修改源代码，系统扩展更方便。\n举个例子 # 实例说明 # 某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置由严格的先后顺序，否则可能会发生记录失败。\n为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统（注：在 Java 中常用的日志记录工具有 SLF4J、Log4j、GCLogViewer、Logstash 等）。\n实例类图 # 通过分析，本实例结构如下图所示：\n日志记录器结构图 Logger 接口充当抽象产品，其子类 FileLogger 和 DatabaseLogger 充当具体产品，LoggerFactory 接口充当抽象工厂，其子类 FileLoggerFactory 和 DatabaseLoggerFactory 充当具体工厂。\n实例代码 # Logger：日志记录器接口，充当抽象产品角色。\npublic interface Logger { public void writeLog(); } DatabaseLogger：数据库日志记录器，充当具体产品角色。\npublic class DatabaseLogger implements Logger { @Override public void writeLog() { System.out.println(\u0026#34;数据库日志记录。\u0026#34;); } } FileLogger：文件日志记录器，充当具体产品角色。\npublic class FileLogger implements Logger { @Override public void writeLog() { System.out.println(\u0026#34;文件日志记录。\u0026#34;); } } LoggerFactory：日志记录工厂接口，充当抽象工厂角色\npublic interface LoggerFactory { public Logger createLogger(); // 抽象工厂方法 } DatabaseLoggerFactory：数据库日志记录器工厂类，充当具体工厂角色。\npublic class DatabaseLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 连接数据库，代码省略 // 创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } } FileLoggerFactory：文件日志记录器工厂类，充当具体工厂角色。\npublic class FileLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 创建文件日志记录器对象 Logger logger = new FileLogger(); // 创建文件，代码省略 return logger; } } Cilent：客户端测试类。\npublic class Client { public static void main(String[] args) { LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); // 可引入配置文件和反射机制实现 logger = factory.createLogger(); logger.writeLog(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n文件日志记录。 如果需要增加并使用新的日志记录器，只需要对应增加一个新的具体工厂类，然后在客户端代码中修改具体工厂类的类名，原有类库的源代码无需做任何修改。\n通过引入配置文件并使用反射机制可以实现在不修改客户端代码的基础上更换具体工厂类，让系统用更加符合开闭原则，具备更好的灵活性和可扩展性。\n反射机制与配置文件 # 上面的实例中，在更换日志记录器时需要修改客户端代码，对于客户端而言并不符合开闭原则，本节将介绍如何在不修改客户端代码的基础上更换或增加新的日志记录方式。\n在实际应用开发中，可以对具体工厂类的实例化过程进行修改，在客户端代码中不直接使用 new 关键字来创建工厂对象，而是通过 Java 反射机制结合配置文件（例如 XML 文件）来生成具体工厂对象。\nJava 反射机制\nJava 反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。\n// 通过类名生成实例对象并将其返回 Class c = Class.forName(\u0026#34;java.lang.String\u0026#34;); Object obj = c.newInstence(); return obj; 配置文件\n软件系统的配置文件通常为 XML 文件，可以使用 DOM（Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）等技术来处理 XML 文件。\n在软件开发中可以把类名存储到 XML 配置文件中，再读取配置文件获取类名字符串，然后通过 Java 反射机制来创建对象。\n\u0026lt;!-- config.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;designpatterns.factorymethod.FileLoggerFactory\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; 为了读取该配置文件，并通过存储再其中的类名字符串反射生成对象，可以创建一个工具类 XMLUtil，其详细代码如下：\nimport org.w3c.dom.*; import javax.xml.parsers.*; import java.io.File; public class XMLUtil { // 该方法用于从 XML 配置文件中提取具体类的类名，并返回一个实例对象 public static Object getBean() { try { // 创建 DOM 文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/factorymethod/config.xml\u0026#34;)); // 获取包含类名的文本结点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } public static void main(String[] args) { Object bean = getBean(); String simpleName = bean.getClass().getSimpleName(); System.out.println(simpleName); } } 有了 XMLUtil 类之后，可以对日志记录器的客户端代码进行修改，不再直接使用 new 关键字来创建具体的工厂类，而是将 具体 工厂列的类名存储在 XML 文件中，再通过 XMLUtil 类的静态工厂方法 getBean() 进行对象的实例化，将代码修改如下：\npublic class Client { public static void main(String[] args) { LoggerFactory factory; Logger logger; factory = (LoggerFactory) XMLUtil.getBean(); // getBean() 的返回类型为 Object，需要进行强制类型转换 logger = factory.createLogger(); logger.writeLog(); } } 在引入 XMLUtil 类和 XML 配置文件之后，如果需要增加一种新类型的日志记录方式，只需要执行以下 4 个步骤：\n新的日志记录器需要继承抽象日志记录器 Logger； 对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂 LoggerFactory，并实现其中的工厂方法 createLogger()，设置好初始化参数和环境变量，返回具体日志记录器对象。 修改配置文件 config.xml，用新增的具体日志记录器工厂类的类名字符串替换原有工厂类的类名字符串。 编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合开闭原则。 工厂方法的重载 # 在某些情况下，可以通过多种方式来初始化同一个产品类。此时可以提供一个重载的工厂方法，以不同的方式对产品对象进行创建。对于同一个具体工厂而言，无论使用哪个工厂方法，所创建的产品类型均要相同。重载的工厂方法结构图如下图所示：\n重载的工厂方法结构图 引入重载方法后，抽象工厂类 LoggerFactory 的代码修改如下：\npublic interface LoggerFactory { public Logger createLogger(); // 抽象工厂方法 public Logger createLogger(String args); public Logger createLogger(Object obj); } 具体工厂类 DatabaseLoggerFactory 的代码修改如下：\npublic class DatabaseLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 使用默认方式连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } @Override public Logger createLogger(String args) { // 使用参数 args 作为连接字符串来连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } @Override public Logger createLogger(Object obj) { // 使用封装在参数 obj 中的连接字符串来连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 使用封装在参数 obj 中的数据来初始化数据库日志记录器，代码省略 return logger; } } // 其他具体工厂类代码省略 工厂方法的隐藏 # 有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时在工厂类中直接调用产品类的业务方法，客户端无需调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。\n如果对客户端隐藏工厂方法，那么日志记录器结构图可修改为如下图所示\n隐藏工厂方法后的日志记录器结构图 抽象工厂类的代码修改如下：\n// 将接口改为抽象类 public abstract class LoggerFactory { // 在工厂类中直接调用日志记录器的业务方法 writeLog() public void writeLog() { Logger logger = this.createLogger(); logger.writeLog(); } public abstract Logger createLogger(); } 客户端代码修改如下：\npublic class Client { public static void main(String[] args) { LoggerFactory factory; factory = (LoggerFactory) XMLUtil.getBean(); factory.writeLog(); // 直接使用工厂对象来调用产品对象的业务方法 } } 工厂方面模式优/缺点与适应环境 # 工厂方法模式优点 # 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部。 使用工厂方法模式的另一个优点是在系统中加入新产品时无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他大的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样系统的可扩展性也就变的非常好，完全符合开闭原则。 工厂方法模式的缺点 # 在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成增加，在一定程度上增加了系统的复杂性，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 工厂方法模式适用环境 # 客户端不知道它所需要的对象的类。 抽象工厂类通过其子类来指定创建哪个对象。 ","date":"2024-7-8","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater04/","section":"Posts","summary":"","title":"04-工厂方法模式","type":"posts"},{"content":" 创建型模式 # 创建型模式（Creational Pattern）关注对象的创建过程，是一类常用的设计模式。创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例和创建细节，让用户在使用对象的时候无需关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。\n创建型模式一览表\n模式名称 定义 学习难度 使用频率 简单工厂模式（Simple Factory Pattern） 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类 ⭐⭐ ⭐⭐⭐ 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 ⭐⭐ ⭐⭐⭐⭐⭐ 抽象工厂方法（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 ⭐⭐⭐⭐ ⭐⭐⭐⭐⭐ 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 ⭐⭐⭐⭐ ⭐⭐ 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象 ⭐⭐⭐ ⭐⭐⭐ 单例模式（Singleton Pattern） 确保一个类只有一个实例 ⭐ ⭐⭐⭐⭐ 简单工厂模式概述 # 简单工厂模式的设计思想和实现过程都比较简单，其基本实现流程如下：\n首先将需要创建的各种不同产品对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需要调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。\n简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式。\n简单工厂模式结构 # 简单工厂模式包含以下 3 个角色\nFactory（工厂角色）：工厂角色即工厂类，他是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。 Product（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 简单工厂模式结构图 简单工厂模式实现 # 在简单工厂模式中客户端通过工厂类来创建一个产品类的实例，而无须直接使用 new 关键字来创建对象，它是工厂模式家族中最简单的一员。\n在使用简单工厂模式时首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，一共不同的具体产品来实现。典型的抽象产品类代码的如下：\npublic abstract class Product { // 所有产品类的公共业务方法 public void methodSame() { // 公共方法的实现 } // 声明抽象业务方法 public abstract void methodDiff(); } 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。典型的具体产品类的代码如下：\npublic class ConcreteProduct extends Product{ // 实现业务方法 public void methodDiff() { // 业务方法的实现 } } 简单工厂模式的核心是工厂类，在没有工厂类之前客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后客户端可以通过工厂类来创建产品，在简单工厂模式中工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。典型的工厂的代码如下：\npublic class Factory { // 静态工厂方法 public static Product getProduct(String arg){ if (arg.equalsIngoreCase(\u0026#34;A\u0026#34;)){ product = new ConcreateProductA(); // 初始化设置 product } else if (arg.equalsIgnoreCase(\u0026#34;B\u0026#34;)){ product = new ConcreateProductB(); // 初始化设置 product } return product; } } 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：\npublic class Client{ public static void main(String args[]){ Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;); // 通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); } } 举个例子 # 实例说明： # 某软件公司要基于 Java 语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart)等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。\n现使用简单工厂模式来设计图表库。\n实例类图 # 图表库结构图 上图中，Chart 接口充当抽象产品类，其子类 HistogramChart、PieChart 和 LineChart 充当具体产品类，ChartFactory 充当工厂类。\n实例代码 # Chart：抽象图表接口，充当抽象产品类。\npublic interface Chart { public void display(); } HistogramChart：柱状图类，充当具体产品类。\npublic class HistogramChart implements Chart { public HistogramChart() { System.out.println(\u0026#34;创建柱状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示柱状图！\u0026#34;); } } PieChart：饼状图类，充当具体产品类。\npublic class PieChart implements Chart { public PieChart() { System.out.println(\u0026#34;创建饼状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示饼状图！\u0026#34;); } } LineChart：折线图类，充当具体产品类。\npublic class LineChart implements Chart { public LineChart() { System.out.println(\u0026#34;创建折线图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示折线图！\u0026#34;); } } ChartFactory：图表工厂类，充当工厂类。\npublic class ChartFactory { // 静态工厂方法 public static Chart getChart(String type) { Chart chart = null; if (type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { chart = new HistogramChart(); System.out.println(\u0026#34;初始化设置柱状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { chart = new PieChart(); System.out.println(\u0026#34;初始化设置饼状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { chart = new LineChart(); System.out.println(\u0026#34;初始化设置折线图！\u0026#34;); } return chart; } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Chart chart; chart = ChartFactory.getChart(\u0026#34;histogram\u0026#34;); // 通过静态方法创建产品 chart.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n创建柱状图！ 初始化设置柱状图！ 显示柱状图！ 在客户端测试类中使用工厂类 ChartFactory 的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可。\n但是创建具体 Chart 对象时必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象，客户端代码需要重新编译，这对于客户端而言违反了开闭原则。\n一种常用的解决方案，可以将静态工厂方法的参数存储在 XML 等配置文件中，通过工具类读取配置文件中的字符串参数，更换图表时只需要改配置文件即可。\n简单工厂模式的简化 # 有时候，为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品中，如下图所示：\n简化的简单工厂模式 简单工厂模式优/缺点与适应环境 # 优点 # 工厂创建对象，客户端使用对象，实现了对象创建和使用的分离； 客户端无需知道创建的具体产品类的类名，可以在一定程度上减少使用者的记忆量； 通过引入配置文件，可以在不修改客户端代码的情况下更换和增加新的具体类，在一定程度上提高了系统的灵活性。 缺点 # 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响； 使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度； 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑。 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 # 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂； 客户端只知道传入工厂类的参数，不关心如何创建对象。 ","date":"2024-7-5","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater03/","section":"Posts","summary":"","title":"03-简单工厂模式","type":"posts"},{"content":" 面向对象的设计原则概述 # 衡量软件质量的重要属性：\n可维护性（Maintainability）\n指软件能够被理解、改正、适应及扩展的难易程度；\n可复用性（Reusability）\n指软件能够被重复使用的难易程度。\n最常见的 7 个面向对象设计原则：\n设计原则名称 定义 使用频率 单一职责原则（Single Responsibility Principle，SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 ⭐⭐⭐⭐ 开闭原则（Open-Close Principle，OCP） 软件实体应带对扩展开放，对修改关闭 ⭐⭐⭐⭐⭐ 里氏代换原则（Liskov Substitution Principle，LSP） 所有引用基类的地方必须透明地使用其子类的对象 ⭐⭐⭐⭐⭐ 依赖倒转原则（Dependence Inversion Principle，DIP） 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 ⭐⭐⭐⭐⭐ 接口隔离原则（Interface Reuse Principle，IRP） 客户端不应该依赖那些它不需要的接口 ⭐⭐ 合成复用原则（Composite Reuse Principle，CRP） 优先使用对象组合，而不是通过继承来达到复用的目的 ⭐⭐⭐⭐ 迪米特法则（Law of Demeter，LoD） 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 ⭐⭐⭐ 单一职责原则 # 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。\nSingle Responsibility Principle(SRP): Every object should hava a single responsibility, and that responsibility should be entirely encapsulated by the class.\n单一职责原则是实现高内聚、低耦合的指导方阵，它是最简单但又是最难运行的原则。\n例如：一个类，既要连接数据库，又要对表格进行操作，又要生成相关的统计图表。对于这个类，我们可以按照单一职责原则，将其拆分成三个类：用于连接数据库的工具类，用于操作数据库表的 DAO 类，用于生成图表并展示的类。\n开闭原则 # 开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。\n开闭原则：软件实体应当对扩展开放，对修改关闭。\nOpen-Close Principle(OCP): Software entities should be open for extension, but closed for modification.\n开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。\n为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。\n很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。\n里氏代换原则 # 以 Barbara Liskov（芭芭拉·利斯科夫）教授的姓氏命名，其严格表述如下：如果对每一个类型为 S 的对象 o1 都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换 o2 时程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。\n这个原始的定义不太容易理解，一般使用它的另一个通俗版定义：\n里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象。\nLiskov Subsitution Principle (LSP): Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\n里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。\n里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。\n依赖倒转原则 # 依赖倒转原则是面向对象设计的主要实现机制之一，是系统抽象化的具体实现。\n依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\nDependence Inversion Principle(DIP): High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.\n简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。\n依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，疯狗则将无法调用到在子类中增加的新方法。\n在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有的系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。\n在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependence Injection, DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，采用抽象的形式来注入所依赖的对象。常用的注入方式有 3 种，分别是构造注入、设值（Setter） 注入和接口注入。\n构造注入是指通过构造函数来传入具体类的对象。 设值注入是指通过 Setter 方法来传入具体类的对象。 接口注入是指通过在接口种声明的业务方法来传入具体类的对象。 大多数情况下，开闭原则、里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。\n接口隔离原则 # 接口隔离原则：客户端不应该依赖那些它不需要的接口。\nInterface Segregation Principle(ISP): Client should not be forced to depend upon interfaces that they do not use.\n当一个接口太大时需要将他分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。\n在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，在接口中仅包含为某一类用户定值的方法即可，不应该强迫客户依赖于那些他们不用的方法。\n合成复用原则 # 合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：\n合成复用原则：优先使用对象组合，而不是通过继承来达到复用的目的。\nComposite Reuse Principle(CRP): Favor composition of objects over inheritance as a reuse mechanism.\n在复用时尽量使用组合/聚合关系（关联关系），少用继承。\n如果两个类之间使“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可以使用继承。\n迪米特法则 # 迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP），其定义如下：\n迪米特法则：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\nLaw of Demeter(LoD): Each unit should have only limited knowledge about other units: only units \u0026ldquo;closely\u0026rdquo; related to the current unit.\n迪米特法则要求一个软件实体应当尽可能地与其他实体发生相互作用。\n迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don\u0026rsquo;t talk to strangers.）、只与你的直接朋友通信（Talk only to your immediate friends.）等。在迪米特法则中，对于一个对象，其朋友包括以下几类：\n当前对象本身（this）。 以参数形式传入到当前对象方法中的对象。 当前对象的成员对象。 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。 当前对象所创建的对象。 应用迪米特法则，可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。通过引入一个合理的“第三者”来降低现有对象之间的耦合度。\n将迪米特法则应用到系统设计中应注意以下几点：\n在类的划分上，尽量创建松耦合的类，有利于复用，松耦合的类一旦被修改，不会对关联的类造成太大影响。 在类的结构设计的上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 ","date":"2024-7-4","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater02/","section":"Posts","summary":"","title":"02-面向对象设计原则","type":"posts"},{"content":" 设计模式的诞生与发展 # 模式的诞生与定义 # 模式（Pattern）起源于建筑业而非软件业，模式之父 \u0026ndash; Christopher Alexander 博士。\n模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案.\nA pattern is a successful or efficient solution to a recurring problem within a context.\n当一个领域逐渐成熟的时候自然会有很多模式。模式是一种直到，在一个良好的指导下有助于设计一个优良的解决方案，达到事半功倍的效果，而且会的到解决问题的最佳办法。\n最早将模式的思想引入软件工程学的是 1991-1992 年以“四人组”（Gang of Four，GOF，分别是 Erich Gamma、Richard helm、Ralph Johnson 和 John Vlissides）自称的 4 位著名软件工程学者。\nGoF 将模式的概念引入软件工程领域，这标志着软件模式的诞生。\n软件模式并非仅仅限于设计模式，还包括架构模式、分析模式和过程模式等。\n软件模式是在一定条件下的软件开发问题及其解法。软件模式的基本结构由 4 个部分构成，即问题描述、前提条件（环境或约束条件）、解法和效果，如下图所示。\n设计模式的定义与分类 # 设计模式的定义 # 设计模式（Design Pattern）是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解并且提高代码的可靠性。\nGoF 对设计模式的定义如下：\n设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定值的解决方案，该方案描述了对象和类之间的相互作用。\nDesign patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.\n设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素有以下 4 个。\n模式名称（Pattern Name）\n通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的。\n问题（Problem）\n问题描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。在对问题进行描述的同时实际上就确定了模式所对应的使用环境以及模式的使用动机。\n解决方案（Solution）\n结局方案描述了设计模式的组成成分，以及这些组成成分的相互关系、各自的职责和协作方式。不针对具体问题，使用抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。\n效果（Consequences）\n效果描述了模式应用的效果以及在使用模式时应权衡的问题。没有一个解决方案是百分之百完美的，在使用设计模式时需要进行合理的评价和选择。\n设计模式的分类 # 设计模式一般有两种分类方式：\n根据目的分类\n分为创建型（Creational）、结构型（Structural）和行为型（Behavioral）三类。\n根据范围分类\n分为类模式和对象模式两种。\nGoF 设计模式简介 # GoF 的 23 种模式一览表 # 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式模板方法模式 对象模式 抽象工厂模式建造者模式原型模式单例模式 （对象）适配器模式桥接模式组合模式装饰模式外观模式享元模式代理模式 职责链模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式 GoF 的 23 种设计模式的简要说明 # 模式类别 模式名称 模式说明 创建型模式（Creational Patterns） 抽象工厂模式（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样得构建过程可以创建不同的表示 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来后创建新的对象 单例模式（Singleton Pattern） 确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例 结构型模式（Structural Patterns） 适配器模式（Adapter Pattern） 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作 桥接模式（Bridge Pattern） 将抽象部分与它的实例部分解耦，使得两者都能够独立变化 组合模式（Composite Pattern） 组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象 装饰模式（Decorator Pattern） 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供一种比使用子类更加灵活的替代方案 外观模式（Façade Pattern） 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 享元模式（Flyweight Pattern） 运用共享技术有效地支持大量细粒度对象的复用 代理模式（Proxy Pattern） 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问 行为型模式（Behavioral Patterns） 职责链模式（Chain of Responsibility Pattern） 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止 命令模式（Command Pattern） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示来解释语言中的句子 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示 中介者模式（Mediator Pattern） 定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 备忘录模式（Memento Pattern） 在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以将对象恢复到原先保存的状态 观察者模式（Observer Pattern） 定义对象直接按的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知被自动更新 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 策略模式（Strategy Pattern） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户而变化 模板方式模式（Template Method Pattern） 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 访问者模式（Visitor Pattern） 表示一个作用与某对象结构中的各个元素的操作。访问者模式可以在不改变各元素的类的前提下定义作用于这些元素的新操作 设计模式的优点 # 设计模式融合了众多专家的经验，并以一种标准的形式供广大开发人员所用，它提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。 设计模式使人们可以更加简单、方便地复用成功的设计和体系结构，将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 设计模式使得设计方案更加灵活，且易于修改。 设计模式的使用将提高软件系统的开发效率和软件质量，并且在一定程度上节约设计成本。 设计模式有助于初学者更深入地理解面向对象思想，一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码，另一方面还可以提高软件的设计水平和代码质量。 ","date":"2024-7-3","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chapter01/","section":"Posts","summary":"","title":"01-设计模式概述","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/hadoop/","section":"Tags","summary":"","title":"Hadoop","type":"tags"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/categories/hadoop/","section":"Categories","summary":"","title":"Hadoop","type":"categories"},{"content":"这篇文章并非原厂，是之前在网上找的，Hadoop MapReduce 的流程图，觉得很不错，就是网上的图太糊了，在这里重置一下。MR 作为大数据处理的基石，顺便梳理一下 MR 的流程。\nMapReduce 一共有 7 个角色参与，分为 4 个大阶段，7 个小阶段。分别是：\n任务启动阶段 由 Client 端发起请求； YarnRunner 接受请求并申请资源； ResourceManager 检索资源情况，分配资源路径给 YarnRunner； YarnRunner 进行分配，申请启动 MRAppMaster； ResourceManager 根据分片和 job 等信息，选择数据所在节点启动 MapTask（程序找数据），唤醒MRAppMaster； MRAppMaster 启动，持续监控和管理任务； MapTask 启动，开始干活； Map 阶段 数据读取，每个 task 读取自己节点上的数据； 数据处理 每个 task 对自己读取到的数据进行 split，分成更小的数据块； 对每个 split 的数据进行 map，提取 key、value、con； 对数据进行分区，有条件建议自定义分区，可以解决数据倾斜的问题，对之后的 reduce 也有极大的优化； 数据进入环形缓冲区，以起始点为赤道，到达溢出比后，刷新赤道； 溢出的数据刷入 sort 进行排序； 排序号的数据放入 spill，进行 merge 后有序写入 HDFS； Reduce 阶段 Reduce 启动 MRAppMaster 监控到 reduce 任务即将结束，开始申请启动 ReduceTask；RM 接受申请，根据分区结果，启动若干 ReduceTask。 ReduceTask启动，把每个 map 结果中的不同分区的数据，shuffle 数据到对应 ReduceTask 所在节点的缓存。 数据处理 在缓存中对每个 sotr 进行 merge（内存、缓存都有）； 将 merge 后的结果，重新进行 spill，排序后，落到 HDFS； 将所有小文件 merge 成一个大文件； Reduce 阶段 调用 Reduce 函数，对排序好的 file 进行汇总； 将最终结果写入到 HDFS 中； 任务结束阶段 MRAppMaster 监控到每个 Reduce 节点的执行情况； 向上汇报，并申请注销自己； RM 注销 MRAppMaster，并向上汇报； YarnRunner 返回任务完成信息； 客户端接受信息，任务结束。 整体流程图如下：\n\u0026hellip; 无奈，图片比较大，显示效果特别差，只能放链接了，后边想办法优化。\n链接：https://pan.baidu.com/s/1cF2CDo5NAzI7vOtQgvo_nw?pwd=r85y\n提取码：r85y\n","date":"2024-7-3","externalUrl":null,"permalink":"/posts/mr-image/","section":"Posts","summary":"","title":"MapReduce流程图（重制版）","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/","section":"Tags","summary":"","title":"大数据","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/categories/%E5%8D%9A%E5%AE%A2/","section":"Categories","summary":"","title":"博客","type":"categories"},{"content":" 选型 # 在 Hexo 和 Hugo 之间纠结了很久，开始尝试使用 Hexo 构建博客，搭建很快，主题很多，生成页面也比较漂亮，但是构建速度慢，外加没有找到自己喜欢的配色。再次尝试使用 Hugo 搭建，构建真快，主题也多，Blowfish 主题文档也全，使用体验真的没话说。\n前置条件 # 使用 Hugo 前，需要自己安装 Go 语言，Node.js，Git 等环境。安装很简单，本人是window系统，下载 amd64 位安装包，点点点，安装完成后验证就可以了。\nHugo 的安装需要注意，直接从 github 上下载 releases 版本的压缩包，解压缩后配置环境变量。Hugo 大部分主题都需要一些高级功能，所以直接下载 扩展版。\n配置好环境变量后，在 CMD 命令行查看是否安装成功。\nhugo version ## 出现如下提示，即为安装成功 hugo v0.128.0-e6d2712ee062321dc2fc49e963597dd5a6157660+extended windows/amd64 BuildDate=2024-06-25T16:15:48Z VendorInfo=gohugoio 开始搭建 # 其实 Hugo 中文文档 和 Blowfish 文档 已经很详细了，这里简要总结一下:\n使用 Hugo 构建项目 # Hugo new site your-site # your-site 请自行修改为自己的项目目录 cd your-site 注意，Hugo new site 要求文件夹必须为空，哪怕是有隐藏文件夹也会导致初始化失败。\n初始化后目录结构如下：\ngit init 各位可以先在 GitHub 上新建一个空白仓库，然后 git clone 下来。\nHugo new site your-site之后，将 .git 文件夹拷贝到 your-site 文件夹下，这样方便后续代码提交。\n安装主题 # 主题我这里使用的是 Blowfish 主题，优点是文档很全，而且文档支持中文，提供了多种主页布局方式和网站配色。我最喜欢的是‘Avocado’这个配色的深色模式，看起来很舒服。\n不建议使用 Blowfish-Tools 工具安装，除非你对 Hugo 框架很熟悉，知道每一个步骤都是在干什么，否则，不推荐使用它。\n推荐使用 使用 Git 子模块安装 主题。\ngit submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 下载好之后，目录 themes 中就会多出来一个 blowfish 的目录，里边就是主题的默认内容。\n设置主题的配置文件 # 在根目录中，删除 Hugo 自动生成的 hugo.toml 文件。从目录 themes/blowfish/config/_default 中复制 *.toml 文件，粘贴到 config/_default/ 目录中。Hugo 可以将这些配置统一放在一个 toml 文件中，也可以分多个 toml 文件，便于更好的管理。\n接着一定要设置 config/_default/hugo.toml 中的 theme = \u0026quot;blowfish\u0026quot;，这样才能使用对用的主题。\n关于 Blowfish 主题如何配置和使用，官网介绍已经很全了，详细内容请查看官网文档：Blowfish 文档 。\n接下来只说几个重要的点：\n自定义网站图标 # Blowfish 主题默认的网站图标是一条蓝色的小河豚，我们可以自定义自己喜欢的图标做自己的网站图标。\n网站图标资源的位置在 static/ 文件夹中，名称必须和下面的名称一样。如果使用了favicon.io，那么下载下来解压后的文件名和下面是完全一致的，直接拷贝到 static/ 中即可。\nstatic/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest 用 Hugo 创建文章 # 用 Hugo 创建一篇文章的命令是：\nhugo new xxx.md 用这个命令创建的 Markdown 文件会套用 archetypes 文件夹中的 front matter 模版，在空白处用 Markdown 写入内容。\n其中，draft = true 代表这篇文章是一个草稿，Hugo 生成页面不会显示草稿，要在主页显示此文章，可以设置 draft = false ，或者直接删掉这行。\n本地调试和预览 # 在发布到网站前，我们可以在本地预览网站的内容和效果，运行命令：\nhugo server 启动完成后，在浏览器输入 http//localhost:1313/ 可以实时预览生成的网站效果。\n使用上边的命令后，会发现文档上 draft = false 的文章不会显示，需要修改启动参数：\nhugo server -D 这样，草稿文章内容也会显示了。\n使用 GitHub Page 构建网站 # Hugo 提供非常详尽的 GitHub Pages 部署指引。这里对部署过程做简单梳理：\n在 ./.github/workflows/ 中放入 hugo.yml；\n将本地网站同步到 GitHub 同名仓库；\n在仓库设置 Settings -\u0026gt; Pages 中选择 Build and deployment 选择 GitHub Actions,将 Hugo 推送到 GitHub 上时,便会自动构建网页。\n完成以上步骤，你便可以通过 https://\u0026lt;your-github-id\u0026gt;.github.io 访问自己的个人博客。\n","date":"2024-6-28","externalUrl":null,"permalink":"/posts/build-blog/","section":"Posts","summary":"","title":"利用 GitHub Pages + Hugo 搭建个人博客","type":"posts"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%AB%99/","section":"Tags","summary":"","title":"网站","type":"tags"},{"content":" 一直在想，是不是做一个博客比较好，抽点时间，记录些东西也挺好。\n纠结了两天用哪个组件建立博客，看了 hexo、hugo 和 astro 三个组件，尝试了 hexo 和 hugo，最终还是决定用 hugo。\n其实在很早之前，我就想做一个自己的博客，记录下自己的学习和成长，哪怕不是技术相关的也好。人生的成长，技术只是一个方面，更多的还有思想、情商。技术力是很重要的一个方面，但也仅仅只是一个方面。\n小时候希望自己长大了当个科学家（貌似当时的教育，大家都是科学家）， 只知道学习，但是还学不好。考了个一般的本科，学了个一般的专业（土木🐶），找了个一般的工作。本想着在自己的专业做出点名堂，谁知道被社会狠狠的毒打。对于工地上的风气，我是深恶痛绝，再加上每周只能歇一天，我果断选择了转行，脱离了苦海。\n我也是挺佩服自己的，什么都不懂，就敢转行，想想年起的自己真的是很有胆量。于是听了同学减建议，背着书包，离开家乡，跑到帝都，租个破房，孤身一人，开始闯荡。一路从 JAVA 干到 大数据，甚至做过前端 VUE 项目，差点把自己干成全栈。熬了这么多年，目前只是一个不合格的组长（2024年）。\n庆幸自己转行的比较早，就目前这个形式，土木感觉都成夕阳行业了，IT 也不再是风口浪尖了，后续给人吹牛，还可以说自己是在浪尖待过那么一段时间的人呢，哈哈。\n趁自己还没老，抓紧做自己喜欢的事情。及时行乐，何尝不是一种洒脱。趁现在，从构建一个博客开始，加油，做自己想做的事情吧。\n","date":"2024-6-25","externalUrl":null,"permalink":"/posts/beginning/","section":"Posts","summary":"","title":"开篇","type":"posts"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/tags/%E9%9A%8F%E6%83%B3/","section":"Tags","summary":"","title":"随想","type":"tags"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/categories/%E6%9D%82%E9%A1%B9/","section":"Categories","summary":"","title":"杂项","type":"categories"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]