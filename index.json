
[{"content":" 创建型模式 # 创建型模式（Creational Pattern）关注对象的创建过程，是一类常用的设计模式。创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例和创建细节，让用户在使用对象的时候无需关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。\n创建型模式一览表\n模式名称 定义 学习难度 使用频率 简单工厂模式（Simple Factory Pattern） 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类 ⭐⭐ ⭐⭐⭐ 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 ⭐⭐ ⭐⭐⭐⭐⭐ 抽象工厂方法（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 ⭐⭐⭐⭐ ⭐⭐⭐⭐⭐ 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 ⭐⭐⭐⭐ ⭐⭐ 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象 ⭐⭐⭐ ⭐⭐⭐ 单例模式（Singleton Pattern） 确保一个类只有一个实例 ⭐ ⭐⭐⭐⭐ 简单工厂模式概述 # 简单工厂模式的设计思想和实现过程都比较简单，其基本实现流程如下：\n首先将需要创建的各种不同产品对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需要调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。\n简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式。\n简单工厂模式结构 # 简单工厂模式包含以下 3 个角色\nFactory（工厂角色）：工厂角色即工厂类，他是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。 Product（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 简单工厂模式结构图 简单工厂模式实现 # 在简单工厂模式中客户端通过工厂类来创建一个产品类的实例，而无须直接使用 new 关键字来创建对象，它是工厂模式家族中最简单的一员。\n在使用简单工厂模式时首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，一共不同的具体产品来实现。典型的抽象产品类代码的如下：\npublic abstract class Product { // 所有产品类的公共业务方法 public void methodSame() { // 公共方法的实现 } // 声明抽象业务方法 public abstract void methodDiff(); } 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。典型的具体产品类的代码如下：\npublic class ConcreteProduct extends Product{ // 实现业务方法 public void methodDiff() { // 业务方法的实现 } } 简单工厂模式的核心是工厂类，在没有工厂类之前客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后客户端可以通过工厂类来创建产品，在简单工厂模式中工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。典型的工厂的代码如下：\npublic class Factory { // 静态工厂方法 public static Product getProduct(String arg){ if (arg.equalsIngoreCase(\u0026#34;A\u0026#34;)){ product = new ConcreateProductA(); // 初始化设置 product } else if (arg.equalsIgnoreCase(\u0026#34;B\u0026#34;)){ product = new ConcreateProductB(); // 初始化设置 product } return product; } } 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：\npublic class Client{ public static void main(String args[]){ Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;); // 通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); } } 举个例子 # 实例说明： # 某软件公司要基于 Java 语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart)等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。\n现使用简单工厂模式来设计图表库。\n实例类图 # 图表库结构图 上图中，Chart 接口充当抽象产品类，其子类 HistogramChart、PieChart 和 LineChart 充当具体产品类，ChartFactory 充当工厂类。\n实例代码 # Chart：抽象图表接口，充当抽象产品类。\npublic interface Chart { public void display(); } HistogramChart：柱状图类，充当具体产品类。\npublic class HistogramChart implements Chart { public HistogramChart() { System.out.println(\u0026#34;创建柱状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示柱状图！\u0026#34;); } } PieChart：饼状图类，充当具体产品类。\npublic class PieChart implements Chart { public PieChart() { System.out.println(\u0026#34;创建饼状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示饼状图！\u0026#34;); } } LineChart：折线图类，充当具体产品类。\npublic class LineChart implements Chart { public LineChart() { System.out.println(\u0026#34;创建折线图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示折线图！\u0026#34;); } } ChartFactory：图表工厂类，充当工厂类。\npublic class ChartFactory { // 静态工厂方法 public static Chart getChart(String type) { Chart chart = null; if (type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { chart = new HistogramChart(); System.out.println(\u0026#34;初始化设置柱状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { chart = new PieChart(); System.out.println(\u0026#34;初始化设置饼状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { chart = new LineChart(); System.out.println(\u0026#34;初始化设置折线图！\u0026#34;); } return chart; } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Chart chart; chart = ChartFactory.getChart(\u0026#34;histogram\u0026#34;); // 通过静态方法创建产品 chart.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n创建柱状图！ 初始化设置柱状图！ 显示柱状图！ 在客户端测试类中使用工厂类 ChartFactory 的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可。\n但是创建具体 Chart 对象时必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象，客户端代码需要重新编译，这对于客户端而言违反了开闭原则。\n一种常用的解决方案，可以将静态工厂方法的参数存储在 XML 等配置文件中，通过工具类读取配置文件中的字符串参数，更换图表时只需要改配置文件即可。\n简单工厂模式的简化 # 有时候，为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品中，如下图所示：\n简化的简单工厂模式 简单工厂模式优/缺点与适应环境 # 优点 # 工厂创建对象，客户端使用对象，实现了对象创建和使用的分离； 客户端无需知道创建的具体产品类的类名，可以在一定程度上减少使用者的记忆量； 通过引入配置文件，可以在不修改客户端代码的情况下更换和增加新的具体类，在一定程度上提高了系统的灵活性。 缺点 # 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响； 使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度； 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑。 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 # 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂； 客户端只知道传入工厂类的参数，不关心如何创建对象。 ","date":"2024-7-5","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater03/","section":"Posts","summary":"","title":"03-简单工厂模式","type":"posts"},{"content":"","date":"2024-7-5","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024-7-5","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2024-7-5","externalUrl":null,"permalink":"/categories/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Categories","summary":"","title":"Java设计模式","type":"categories"},{"content":"","date":"2024-7-5","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-7-5","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"弱小和无知不是生存的障碍，傲慢才是。\n三体\n","date":"2024-7-5","externalUrl":null,"permalink":"/","section":"你应该看不见我吧","summary":"","title":"你应该看不见我吧","type":"page"},{"content":"","date":"2024-7-5","externalUrl":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"设计模式","type":"tags"},{"content":" 面向对象的设计原则概述 # 衡量软件质量的重要属性：\n可维护性（Maintainability）\n指软件能够被理解、改正、适应及扩展的难易程度；\n可复用性（Reusability）\n指软件能够被重复使用的难易程度。\n最常见的 7 个面向对象设计原则：\n设计原则名称 定义 使用频率 单一职责原则（Single Responsibility Principle，SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 ⭐⭐⭐⭐ 开闭原则（Open-Close Principle，OCP） 软件实体应带对扩展开放，对修改关闭 ⭐⭐⭐⭐⭐ 里氏代换原则（Liskov Substitution Principle，LSP） 所有引用基类的地方必须透明地使用其子类的对象 ⭐⭐⭐⭐⭐ 依赖倒转原则（Dependence Inversion Principle，DIP） 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 ⭐⭐⭐⭐⭐ 接口隔离原则（Interface Reuse Principle，IRP） 客户端不应该依赖那些它不需要的接口 ⭐⭐ 合成复用原则（Composite Reuse Principle，CRP） 优先使用对象组合，而不是通过继承来达到复用的目的 ⭐⭐⭐⭐ 迪米特法则（Law of Demeter，LoD） 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 ⭐⭐⭐ 单一职责原则 # 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。\nSingle Responsibility Principle(SRP): Every object should hava a single responsibility, and that responsibility should be entirely encapsulated by the class.\n单一职责原则是实现高内聚、低耦合的指导方阵，它是最简单但又是最难运行的原则。\n例如：一个类，既要连接数据库，又要对表格进行操作，又要生成相关的统计图表。对于这个类，我们可以按照单一职责原则，将其拆分成三个类：用于连接数据库的工具类，用于操作数据库表的 DAO 类，用于生成图表并展示的类。\n开闭原则 # 开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。\n开闭原则：软件实体应当对扩展开放，对修改关闭。\nOpen-Close Principle(OCP): Software entities should be open for extension, but closed for modification.\n开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。\n为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。\n很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。\n里氏代换原则 # 以 Barbara Liskov（芭芭拉·利斯科夫）教授的姓氏命名，其严格表述如下：如果对每一个类型为 S 的对象 o1 都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换 o2 时程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。\n这个原始的定义不太容易理解，一般使用它的另一个通俗版定义：\n里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象。\nLiskov Subsitution Principle (LSP): Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\n里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。\n里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。\n依赖倒转原则 # 依赖倒转原则是面向对象设计的主要实现机制之一，是系统抽象化的具体实现。\n依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\nDependence Inversion Principle(DIP): High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.\n简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。\n依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，疯狗则将无法调用到在子类中增加的新方法。\n在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有的系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。\n在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependence Injection, DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，采用抽象的形式来注入所依赖的对象。常用的注入方式有 3 种，分别是构造注入、设值（Setter） 注入和接口注入。\n构造注入是指通过构造函数来传入具体类的对象。 设值注入是指通过 Setter 方法来传入具体类的对象。 接口注入是指通过在接口种声明的业务方法来传入具体类的对象。 大多数情况下，开闭原则、里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。\n接口隔离原则 # 接口隔离原则：客户端不应该依赖那些它不需要的接口。\nInterface Segregation Principle(ISP): Client should not be forced to depend upon interfaces that they do not use.\n当一个接口太大时需要将他分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。\n在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，在接口中仅包含为某一类用户定值的方法即可，不应该强迫客户依赖于那些他们不用的方法。\n合成复用原则 # 合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：\n合成复用原则：优先使用对象组合，而不是通过继承来达到复用的目的。\nComposite Reuse Principle(CRP): Favor composition of objects over inheritance as a reuse mechanism.\n在复用时尽量使用组合/聚合关系（关联关系），少用继承。\n如果两个类之间使“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可以使用继承。\n迪米特法则 # 迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP），其定义如下：\n迪米特法则：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\nLaw of Demeter(LoD): Each unit should have only limited knowledge about other units: only units \u0026ldquo;closely\u0026rdquo; related to the current unit.\n迪米特法则要求一个软件实体应当尽可能地与其他实体发生相互作用。\n迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don\u0026rsquo;t talk to strangers.）、只与你的直接朋友通信（Talk only to your immediate friends.）等。在迪米特法则中，对于一个对象，其朋友包括以下几类：\n当前对象本身（this）。 以参数形式传入到当前对象方法中的对象。 当前对象的成员对象。 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。 当前对象所创建的对象。 应用迪米特法则，可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。通过引入一个合理的“第三者”来降低现有对象之间的耦合度。\n将迪米特法则应用到系统设计中应注意以下几点：\n在类的划分上，尽量创建松耦合的类，有利于复用，松耦合的类一旦被修改，不会对关联的类造成太大影响。 在类的结构设计的上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 ","date":"2024-7-4","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater02/","section":"Posts","summary":"","title":"02-面向对象设计原则","type":"posts"},{"content":" 设计模式的诞生与发展 # 模式的诞生与定义 # 模式（Pattern）起源于建筑业而非软件业，模式之父 \u0026ndash; Christopher Alexander 博士。\n模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案.\nA pattern is a successful or efficient solution to a recurring problem within a context.\n当一个领域逐渐成熟的时候自然会有很多模式。模式是一种直到，在一个良好的指导下有助于设计一个优良的解决方案，达到事半功倍的效果，而且会的到解决问题的最佳办法。\n最早将模式的思想引入软件工程学的是 1991-1992 年以“四人组”（Gang of Four，GOF，分别是 Erich Gamma、Richard helm、Ralph Johnson 和 John Vlissides）自称的 4 位著名软件工程学者。\nGoF 将模式的概念引入软件工程领域，这标志着软件模式的诞生。\n软件模式并非仅仅限于设计模式，还包括架构模式、分析模式和过程模式等。\n软件模式是在一定条件下的软件开发问题及其解法。软件模式的基本结构由 4 个部分构成，即问题描述、前提条件（环境或约束条件）、解法和效果，如下图所示。\n设计模式的定义与分类 # 设计模式的定义 # 设计模式（Design Pattern）是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解并且提高代码的可靠性。\nGoF 对设计模式的定义如下：\n设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定值的解决方案，该方案描述了对象和类之间的相互作用。\nDesign patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.\n设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素有以下 4 个。\n模式名称（Pattern Name）\n通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的。\n问题（Problem）\n问题描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。在对问题进行描述的同时实际上就确定了模式所对应的使用环境以及模式的使用动机。\n解决方案（Solution）\n结局方案描述了设计模式的组成成分，以及这些组成成分的相互关系、各自的职责和协作方式。不针对具体问题，使用抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。\n效果（Consequences）\n效果描述了模式应用的效果以及在使用模式时应权衡的问题。没有一个解决方案是百分之百完美的，在使用设计模式时需要进行合理的评价和选择。\n设计模式的分类 # 设计模式一般有两种分类方式：\n根据目的分类\n分为创建型（Creational）、结构型（Structural）和行为型（Behavioral）三类。\n根据范围分类\n分为类模式和对象模式两种。\nGoF 设计模式简介 # GoF 的 23 种模式一览表 # 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式模板方法模式 对象模式 抽象工厂模式建造者模式原型模式单例模式 （对象）适配器模式桥接模式组合模式装饰模式外观模式享元模式代理模式 职责链模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式 GoF 的 23 种设计模式的简要说明 # 模式类别 模式名称 模式说明 创建型模式（Creational Patterns） 抽象工厂模式（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样得构建过程可以创建不同的表示 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来后创建新的对象 单例模式（Singleton Pattern） 确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例 结构型模式（Structural Patterns） 适配器模式（Adapter Pattern） 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作 桥接模式（Bridge Pattern） 将抽象部分与它的实例部分解耦，使得两者都能够独立变化 组合模式（Composite Pattern） 组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象 装饰模式（Decorator Pattern） 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供一种比使用子类更加灵活的替代方案 外观模式（Façade Pattern） 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 享元模式（Flyweight Pattern） 运用共享技术有效地支持大量细粒度对象的复用 代理模式（Proxy Pattern） 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问 行为型模式（Behavioral Patterns） 职责链模式（Chain of Responsibility Pattern） 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止 命令模式（Command Pattern） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示来解释语言中的句子 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示 中介者模式（Mediator Pattern） 定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 备忘录模式（Memento Pattern） 在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以将对象恢复到原先保存的状态 观察者模式（Observer Pattern） 定义对象直接按的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知被自动更新 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 策略模式（Strategy Pattern） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户而变化 模板方式模式（Template Method Pattern） 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 访问者模式（Visitor Pattern） 表示一个作用与某对象结构中的各个元素的操作。访问者模式可以在不改变各元素的类的前提下定义作用于这些元素的新操作 设计模式的优点 # 设计模式融合了众多专家的经验，并以一种标准的形式供广大开发人员所用，它提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。 设计模式使人们可以更加简单、方便地复用成功的设计和体系结构，将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 设计模式使得设计方案更加灵活，且易于修改。 设计模式的使用将提高软件系统的开发效率和软件质量，并且在一定程度上节约设计成本。 设计模式有助于初学者更深入地理解面向对象思想，一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码，另一方面还可以提高软件的设计水平和代码质量。 ","date":"2024-7-3","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chapter01/","section":"Posts","summary":"","title":"01-设计模式概述","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/hadoop/","section":"Tags","summary":"","title":"Hadoop","type":"tags"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/categories/hadoop/","section":"Categories","summary":"","title":"Hadoop","type":"categories"},{"content":"这篇文章并非原厂，是之前在网上找的，Hadoop MapReduce 的流程图，觉得很不错，就是网上的图太糊了，在这里重置一下。MR 作为大数据处理的基石，顺便梳理一下 MR 的流程。\nMapReduce 一共有 7 个角色参与，分为 4 个大阶段，7 个小阶段。分别是：\n任务启动阶段 由 Client 端发起请求； YarnRunner 接受请求并申请资源； ResourceManager 检索资源情况，分配资源路径给 YarnRunner； YarnRunner 进行分配，申请启动 MRAppMaster； ResourceManager 根据分片和 job 等信息，选择数据所在节点启动 MapTask（程序找数据），唤醒MRAppMaster； MRAppMaster 启动，持续监控和管理任务； MapTask 启动，开始干活； Map 阶段 数据读取，每个 task 读取自己节点上的数据； 数据处理 每个 task 对自己读取到的数据进行 split，分成更小的数据块； 对每个 split 的数据进行 map，提取 key、value、con； 对数据进行分区，有条件建议自定义分区，可以解决数据倾斜的问题，对之后的 reduce 也有极大的优化； 数据进入环形缓冲区，以起始点为赤道，到达溢出比后，刷新赤道； 溢出的数据刷入 sort 进行排序； 排序号的数据放入 spill，进行 merge 后有序写入 HDFS； Reduce 阶段 Reduce 启动 MRAppMaster 监控到 reduce 任务即将结束，开始申请启动 ReduceTask；RM 接受申请，根据分区结果，启动若干 ReduceTask。 ReduceTask启动，把每个 map 结果中的不同分区的数据，shuffle 数据到对应 ReduceTask 所在节点的缓存。 数据处理 在缓存中对每个 sotr 进行 merge（内存、缓存都有）； 将 merge 后的结果，重新进行 spill，排序后，落到 HDFS； 将所有小文件 merge 成一个大文件； Reduce 阶段 调用 Reduce 函数，对排序好的 file 进行汇总； 将最终结果写入到 HDFS 中； 任务结束阶段 MRAppMaster 监控到每个 Reduce 节点的执行情况； 向上汇报，并申请注销自己； RM 注销 MRAppMaster，并向上汇报； YarnRunner 返回任务完成信息； 客户端接受信息，任务结束。 整体流程图如下：\n\u0026hellip; 无奈，图片比较大，显示效果特别差，只能放链接了，后边想办法优化。\n链接：https://pan.baidu.com/s/1cF2CDo5NAzI7vOtQgvo_nw?pwd=r85y\n提取码：r85y\n","date":"2024-7-3","externalUrl":null,"permalink":"/posts/mr-image/","section":"Posts","summary":"","title":"MapReduce流程图（重制版）","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/","section":"Tags","summary":"","title":"大数据","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/categories/%E5%8D%9A%E5%AE%A2/","section":"Categories","summary":"","title":"博客","type":"categories"},{"content":" 选型 # 在 Hexo 和 Hugo 之间纠结了很久，开始尝试使用 Hexo 构建博客，搭建很快，主题很多，生成页面也比较漂亮，但是构建速度慢，外加没有找到自己喜欢的配色。再次尝试使用 Hugo 搭建，构建真快，主题也多，Blowfish 主题文档也全，使用体验真的没话说。\n前置条件 # 使用 Hugo 前，需要自己安装 Go 语言，Node.js，Git 等环境。安装很简单，本人是window系统，下载 amd64 位安装包，点点点，安装完成后验证就可以了。\nHugo 的安装需要注意，直接从 github 上下载 releases 版本的压缩包，解压缩后配置环境变量。Hugo 大部分主题都需要一些高级功能，所以直接下载 扩展版。\n配置好环境变量后，在 CMD 命令行查看是否安装成功。\nhugo version ## 出现如下提示，即为安装成功 hugo v0.128.0-e6d2712ee062321dc2fc49e963597dd5a6157660+extended windows/amd64 BuildDate=2024-06-25T16:15:48Z VendorInfo=gohugoio 开始搭建 # 其实 Hugo 中文文档 和 Blowfish 文档 已经很详细了，这里简要总结一下:\n使用 Hugo 构建项目 # Hugo new site your-site # your-site 请自行修改为自己的项目目录 cd your-site 注意，Hugo new site 要求文件夹必须为空，哪怕是有隐藏文件夹也会导致初始化失败。\n初始化后目录结构如下：\ngit init 各位可以先在 GitHub 上新建一个空白仓库，然后 git clone 下来。\nHugo new site your-site之后，将 .git 文件夹拷贝到 your-site 文件夹下，这样方便后续代码提交。\n安装主题 # 主题我这里使用的是 Blowfish 主题，优点是文档很全，而且文档支持中文，提供了多种主页布局方式和网站配色。我最喜欢的是‘Avocado’这个配色的深色模式，看起来很舒服。\n不建议使用 Blowfish-Tools 工具安装，除非你对 Hugo 框架很熟悉，知道每一个步骤都是在干什么，否则，不推荐使用它。\n推荐使用 使用 Git 子模块安装 主题。\ngit submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 下载好之后，目录 themes 中就会多出来一个 blowfish 的目录，里边就是主题的默认内容。\n设置主题的配置文件 # 在根目录中，删除 Hugo 自动生成的 hugo.toml 文件。从目录 themes/blowfish/config/_default 中复制 *.toml 文件，粘贴到 config/_default/ 目录中。Hugo 可以将这些配置统一放在一个 toml 文件中，也可以分多个 toml 文件，便于更好的管理。\n接着一定要设置 config/_default/hugo.toml 中的 theme = \u0026quot;blowfish\u0026quot;，这样才能使用对用的主题。\n关于 Blowfish 主题如何配置和使用，官网介绍已经很全了，详细内容请查看官网文档：Blowfish 文档 。\n接下来只说几个重要的点：\n自定义网站图标 # Blowfish 主题默认的网站图标是一条蓝色的小河豚，我们可以自定义自己喜欢的图标做自己的网站图标。\n网站图标资源的位置在 static/ 文件夹中，名称必须和下面的名称一样。如果使用了favicon.io，那么下载下来解压后的文件名和下面是完全一致的，直接拷贝到 static/ 中即可。\nstatic/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest 用 Hugo 创建文章 # 用 Hugo 创建一篇文章的命令是：\nhugo new xxx.md 用这个命令创建的 Markdown 文件会套用 archetypes 文件夹中的 front matter 模版，在空白处用 Markdown 写入内容。\n其中，draft = true 代表这篇文章是一个草稿，Hugo 生成页面不会显示草稿，要在主页显示此文章，可以设置 draft = false ，或者直接删掉这行。\n本地调试和预览 # 在发布到网站前，我们可以在本地预览网站的内容和效果，运行命令：\nhugo server 启动完成后，在浏览器输入 http//localhost:1313/ 可以实时预览生成的网站效果。\n使用上边的命令后，会发现文档上 draft = false 的文章不会显示，需要修改启动参数：\nhugo server -D 这样，草稿文章内容也会显示了。\n使用 GitHub Page 构建网站 # Hugo 提供非常详尽的 GitHub Pages 部署指引。这里对部署过程做简单梳理：\n在 ./.github/workflows/ 中放入 hugo.yml；\n将本地网站同步到 GitHub 同名仓库；\n在仓库设置 Settings -\u0026gt; Pages 中选择 Build and deployment 选择 GitHub Actions,将 Hugo 推送到 GitHub 上时,便会自动构建网页。\n完成以上步骤，你便可以通过 https://\u0026lt;your-github-id\u0026gt;.github.io 访问自己的个人博客。\n","date":"2024-6-28","externalUrl":null,"permalink":"/posts/build-blog/","section":"Posts","summary":"","title":"利用 GitHub Pages + Hugo 搭建个人博客","type":"posts"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%AB%99/","section":"Tags","summary":"","title":"网站","type":"tags"},{"content":" 一直在想，是不是做一个博客比较好，抽点时间，记录些东西也挺好。\n纠结了两天用哪个组件建立博客，看了 hexo、hugo 和 astro 三个组件，尝试了 hexo 和 hugo，最终还是决定用 hugo。\n其实在很早之前，我就想做一个自己的博客，记录下自己的学习和成长，哪怕不是技术相关的也好。人生的成长，技术只是一个方面，更多的还有思想、情商。技术力是很重要的一个方面，但也仅仅只是一个方面。\n小时候希望自己长大了当个科学家（貌似当时的教育，大家都是科学家）， 只知道学习，但是还学不好。考了个一般的本科，学了个一般的专业（土木🐶），找了个一般的工作。本想着在自己的专业做出点名堂，谁知道被社会狠狠的毒打。对于工地上的风气，我是深恶痛绝，再加上每周只能歇一天，我果断选择了转行，脱离了苦海。\n我也是挺佩服自己的，什么都不懂，就敢转行，想想年起的自己真的是很有胆量。于是听了同学减建议，背着书包，离开家乡，跑到帝都，租个破房，孤身一人，开始闯荡。一路从 JAVA 干到 大数据，甚至做过前端 VUE 项目，差点把自己干成全栈。熬了这么多年，目前只是一个不合格的组长（2024年）。\n庆幸自己转行的比较早，就目前这个形式，土木感觉都成夕阳行业了，IT 也不再是风口浪尖了，后续给人吹牛，还可以说自己是在浪尖待过那么一段时间的人呢，哈哈。\n趁自己还没老，抓紧做自己喜欢的事情。及时行乐，何尝不是一种洒脱。趁现在，从构建一个博客开始，加油，做自己想做的事情吧。\n","date":"2024-6-25","externalUrl":null,"permalink":"/posts/beginning/","section":"Posts","summary":"","title":"开篇","type":"posts"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/tags/%E9%9A%8F%E6%83%B3/","section":"Tags","summary":"","title":"随想","type":"tags"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/categories/%E6%9D%82%E9%A1%B9/","section":"Categories","summary":"","title":"杂项","type":"categories"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]