
[{"content":"","date":"2024-7-18","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" 适配器模式概述 # 我们国家生活用电是 220V，而笔记本、手机等电子设备的工作电压没有这么高，为了使这些电子设备可以使用 220V 的生活用电，就需要使用电源适配器。\n在软件开发中有时也存在类似这种不兼容的情况，也可以像引入一个电源适配器那样，引入一个称为适配器的角色来协调这种存在不兼容的结构，这种设计方案即为适配器模式。\n在适配器模式中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象称为适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。\n适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。\nAdapter Pattern: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn\u0026rsquo;t otherwise because of incompatible interfaces.\n适配器模式的别名为包装类（Wrapper）模式，它既可以作为类结构型模式，也可以作为对象结构型模式。\n适配器模式结构 # 适配器模式包括类适配器和对象适配器。\n类适配器模式的结构如下 图1 所示：\n图1 类适配器模式结构图 对象适配器模式的结构图如下 图2 所示：\n图2 对象适配器模式结构图 适配器模式包含以下 3 个角色。\nTarget（目标抽象类）：目标抽象类定义客户所需的接口，可以使一个抽象类或接口，也可以是具体类。在类适配器中，由于 Java 语言不支持多重继承，它只能是接口。 Adapter（适配器类）：它可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配。适配器类是适配器模式的核心，在类适配器中，它通过实现 Target 接口并继承 Adaptee 类来使二者产生联系，在对象适配器中，它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。 适配器模式实现 # 类适配器 # 在类适配器中适配者类 Adaptee 没有 request() 方法，而客户端期待这个方法，蛋仔适配者类中实现了 specificRequest() 方法，该方法提供的实现正是客户端所需要的。为了使客户端能够使用适配者类，提供了一个中间类，即适配器类 Adapter，适配器类实现了抽象目标接口 Target，并继承了适配者类，在适配器类 request() 方法中调用所继承的适配者类的 specificRequest() 方法，达到了适配的目的。因为适配器类和适配者类是继承关系，所以这种适配器模式称为类适配器模式。典型代码如下：\npublic class Adapter extends Adaptee implements Target { public void request() { super.specificRequest(); } } 对象适配器 # 在对象适配器中客户端需要调用 request() 方法，而适配者类 Adaptee() 没有该方法，但是它提供的 specificRequest() 方法确实客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类 Adapter，即适配器类。这个包装类包装类一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的 request() 方法中调用适配者的 specificRequest() 方法。因为适配器类与适配者类是关联关系（也称委派关系），所以这种适配器模式称为对象适配器模式。典型代码如下：\npublic class Adapter extends Target { private Adaptee adaptee; // 维持一个对适配者对象的引用 public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { adaptee.specificRequest(); // 转发调用 } } 适配器模式更多的是强调对代码的组织，而不是功能的实现。在实际开发中，对象适配器的使用频率更高。\n适配器模式应用实例 # 实例说明 # 某公司要开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁和声音提示的程序，为了重用先前的代码并且使汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。\n实例类图 # 汽车控制软件结构图 实例代码 # CarController：汽车控制类，充当目标抽象类。\npublic abstract class CarController { public void move() { System.out.println(\u0026#34;玩具汽车移动！\u0026#34;); } public abstract void phonate(); // 发出声音 public abstract void twinkle(); // 灯光闪烁 } PoliceSound：警笛类，充当适配者。\npublic class PoliceSound { public void alarmSound() { System.out.println(\u0026#34;发出警笛声！\u0026#34;); } } PoliceLamp：警灯类，充当适配者。\npublic class PoliceLamp { public void alarmLamp() { System.out.println(\u0026#34;呈现警灯闪烁！\u0026#34;); } } PoliceCarAdapter：警车适配器，充当适配器。\npublic class PoliceCarAdapter extends CarController { private PoliceSound sound; // 定义i适配者 PoliceSound 对象 private PoliceLamp lamp; // 定义适配者 PoliceLamp 对象 public PoliceCarAdapter() { sound = new PoliceSound(); lamp = new PoliceLamp(); } // 发出警笛声音 @Override public void phonate() { sound.alarmSound(); // 调用适配者类 PoliceSound 的方法 } // 呈现警灯闪烁 @Override public void twinkle() { lamp.alarmLamp(); // 调用适配者类 PoliceLamp 的方法 } } 配置文件 config.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.adapter.demo.PoliceCarAdapter\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; Client：客户端测试类\npublic class Client { public static void main(String[] args) { CarController car; car = (CarController) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/adapter/demo/config.xml\u0026#34;); car.move(); car.phonate(); car.twinkle(); } } 结果及分析 # 运行程序，输出结果如下：\n玩具汽车移动！ 发出警笛声音！ 呈现警灯闪烁！ 本实例中使用了对象适配器模式，同时引入了配置文件，如果需要使用其他声音类或者灯光类，可以增加一个新的适配器类，使用新的适配器来适配新的声音或者灯光类，原有代码无需修改，符合开闭原则。\n在本实例中目标抽象类是一个抽象类，而不是接口，并且实力中的适配器类 PoliceCarAdapter 同时适配了两个适配者，由于 Java 语言不支持多重类继承，因此本实例只能通过对象适配器来实现，而不能使用类适配器。在实际软件开发中对象适配器比类适配器更加灵活，使用频率更高。\n缺省适配器模式 # 缺省适配其模式是适配器模式的一种变体，其应用也比较广泛。\n缺省适配器模式（Default Adapter Pattern）：当不需要实现一个接口提供的所有方法时，可现设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适合于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。\n缺省适配器模式结构如下图所示：\n缺省适配器模式结构图 包含以下 3 个角色：\nServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。 AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在 ServiceInterface 接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。 ConcreteServiceClass（具体业务类）：它是缺省适配器类的字类，在没有引入适配器之前它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无需使用的方法不得不提供空实现。在有了缺省适配器之后可以直接继承该适配器类，根据需要有选择地覆盖在适配器类中定义的方法。 缺省适配器类的典型代码片段如下：\npublic abstract class AbstractServiceClass implements ServiceInterface { public void serviceMethod1() { } // 空方法 public void serviceMethod2() { } // 空方法 public void serviceMethod3() { } // 空方法 } 双向适配器 # 在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中方法，那么该适配器就是一个双向适配器，其结构如下图所示：\n双向适配器结构示意图 双向适配器的实现较为复杂，其典型代码如下：\npublic class Adapter implements Target, Adaptee { // 同时维持对抽象目标类和适配者的引用 private Target target; private Adaptee adaptee; public Adapter(Target target) { this.target = target; } public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { adaptee.specificRequest(); } public void specificRequest() { target.request() } } 适配器模式优点 # 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好，通过配置文件可以很方便地更换适配器，也无需修改原有代码，完全符合开闭原则。 具体来说，对于类适配器还有以下优点：\n由于适配器是适配者类的字类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器模式还有一下优点：\n一个对象适配器可以把多个不同的适配者适配到同一个目标； 可以适配一个适配者的字类，由于适配器和适配者时间是管理关系，根据里氏代换原则，适配者的字类也可通过该适配器进行适配。 适配器模式缺点 # 对于不支持多重继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。 适配者类不能为最终类。 在 Java、C# 等语言中，类适配器模式中的目标类只能为接口，不能为类，其使用具有一定的局限性。 对象适配器与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。 适配器模式适用环境 # 系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类（包括一些可能在将来引进的类）一起工作。 ","date":"2024-7-18","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater09/","section":"Posts","summary":"","title":"Chpater09","type":"posts"},{"content":"","date":"2024-7-18","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2024-7-18","externalUrl":null,"permalink":"/categories/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Categories","summary":"","title":"Java设计模式","type":"categories"},{"content":"","date":"2024-7-18","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-7-18","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"弱小和无知不是生存的障碍，傲慢才是。\n三体\n","date":"2024-7-18","externalUrl":null,"permalink":"/","section":"你应该看不见我吧","summary":"","title":"你应该看不见我吧","type":"page"},{"content":"","date":"2024-7-18","externalUrl":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"设计模式","type":"tags"},{"content":" 单例模式概述 # 对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个计时工具或 ID（序号）生成器。\n单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\nSingleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.\n单例模式是一种对象创建型模式。有 3 个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n单例模式结构 # 单例模式是结构最简单的设计模式，它只包含一个类，即单例类。结构图如下图所示：\n单例模式结构图 单例模式只包含一个单例角色，就是 Singleton。\n对于 Singleton，在单例类的内部创建它的唯一实例，并通过静态方法 getInstance() 让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为 private；在单例类内部定义了一个 Singleton 类型的静态对象作为供外部共享访问的唯一实例。\n单例模式实现 # 单例模式包含的角色只有一个，也就是单例类 Singleton。单例类拥有一个私有构造函数，确保用户无法通过 new 关键字直接实例化它。除此之外，在单例类中还包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。\n单例模式的实现代码如下：\npublic class Singleton { private static Singleton instance = null; // 静态私有成员变量 // 私有构造方法 private Singleton() { } // 静态公有工厂方法，返回唯一实例 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 为了测试单例类所创建对象的唯一性，可以编写一下客户端测试代码：\npublic class Client { public static void main(String[] args) { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); // 判断两个对象是否相同 if(s1 == s2) { System.out.println(\u0026#34;两个对象实例相同\u0026#34;)； } else { System.out.println(\u0026#34;两个对象实例不同\u0026#34;)； } } } 输出结果为：\n两个对象是实例相同 这说明两次调用 getInstance() 时所获取的对象是同一实例对象，且无法在外部对 Singleton 进行实例化，因此确保系统中只有唯一的一个 Singleton 对象。\n在单例模式的实现过程中需要注意以下 3 点：\n单例类构造函数的可见性为 private。 提供一个类型为自身的静态私有成员变量。 提供一个供油的静态工厂方法。 单例模式应用实例 # 实例说明 # 某软件公司承接了一个服务器负载均衡（Load Balance）软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短相应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。\n实例类图 # 通过分析，本实例的结构图如下所示：\n服务器负载均衡器结构图 实例代码 # LoadBalancer：负载均衡类，充当单例角色。在真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，此处只列出部分与模式相关的核心代码。\npublic class LoadBalancer { // 私有静态成员变量，存储唯一实例 private static LoadBalancer instance = null; // 服务器集合 private List\u0026lt;String\u0026gt; serverList = null; // 私有构造函数 private LoadBalancer() { serverList = new ArrayList\u0026lt;\u0026gt;(); } // 公有静态成员方法，返回唯一实例 public static LoadBalancer getLoadBalancer() { if (instance == null) { instance = new LoadBalancer(); } return instance; } // 增加服务器 public void addServer(String server) { serverList.add(server); } // 删除服务器 public void removeServer(String server) { serverList.remove(server); } // 使用 Random 类随机获取服务器 public String getServer() { Random random = new Random(); int i = random.nextInt(serverList.size()); return serverList.get(i); } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { // 创建 4 个 LoadBalancer 对象 LoadBalancer balancer1, balancer2, balancer3, balancer4; balancer1 = LoadBalancer.getLoadBalancer(); balancer2 = LoadBalancer.getLoadBalancer(); balancer3 = LoadBalancer.getLoadBalancer(); balancer4 = LoadBalancer.getLoadBalancer(); // 判断服务器负载均衡器是否相同 if (balancer1 == balancer2 \u0026amp;\u0026amp; balancer2 == balancer3 \u0026amp;\u0026amp; balancer3 == balancer4) { System.out.println(\u0026#34;服务器负载均衡器具有唯一性！\u0026#34;); } // 增加服务器 balancer1.addServer(\u0026#34;Server 1\u0026#34;); balancer1.addServer(\u0026#34;Server 2\u0026#34;); balancer1.addServer(\u0026#34;Server 3\u0026#34;); balancer1.addServer(\u0026#34;Server 4\u0026#34;); // 模拟客户端请求的分发，如果输出结果为同一个 server，可以将 i 适当放大 // 例如，改为 \u0026#34;i \u0026lt; 100\u0026#34; for (int i = 0; i \u0026lt; 10; i++) { String server = balancer1.getServer(); System.out.println(\u0026#34;分发请求至服务器：\u0026#34; + server); } } } 运行结果及分析 # 服务器负载均衡器具有唯一性！ 分发请求至服务器：Server 1 分发请求至服务器：Server 2 分发请求至服务器：Server 1 分发请求至服务器：Server 2 分发请求至服务器：Server 1 分发请求至服务器：Server 3 分发请求至服务器：Server 2 分发请求至服务器：Server 1 分发请求至服务器：Server 3 分发请求至服务器：Server 2 虽然创建了 4 个 LoadBalancer 对象，但是它们实际上是同一个对象，因此通过使用单例模式可以确保 LoadBalancer 对象的唯一性。\n饿汉式单例和懒汉式单例 # 饿汉式单例 # 饿汉式单例（Eager Singleton）是实现起来最简单的单例类，其结构图如下图所示：\n饿汉式单例结构图 从图中可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载时单例对象就已创建，代码如下：\npublic class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() {} public static EagerSingleton getInstance() { return instance; } } 当类被加载时，静态变量 instance 会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。\n懒汉式单例类与双重检查锁定 # 与饿汉式单例类相同的是，懒汉式单例类（Lazy Singleton）的构造函数也是私有的。与懒汉式单例不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。其结构图如下：\n懒汉式单例结构图 懒汉式单例在第一次调用 getInstance() 方法时实例化，在了加载时并不自行实例化，这种技术称为延迟加载（懒加载 Lazy Load）技术，即需要的时候再加载实例。为了避免多个线程同时调用 getInstance() 方法，可以使用关键字 synchronized，代码如下：\npublic class LazySingleton { private static LazySingleton instance = null; private LazySingleton() { } // 使用 synchronized 关键字对方法加锁，确保任意时刻只有一个线程可执行该方法 synchronized public static LazySingleton getInstance() { if(instance == null) { instance = new LazySingleton(); } return instance; } } 上述代码虽然解决了线程安全问题，但是每次调用 getInstance() 时都需要进行线程锁定判断，在多线程高并发访问环境中将会导致系统性能大大降低，因此需要继续进行改写，getInstance() 方法可以进行如下改写。\n... public static LazySingleton getInstance() { if(instance == null) { synchronize(LazySingleton.class) { instance = new LazySingleton(); } } return instance; } ... 这样实现单例类后，还是会存在单例对象不唯一的情况，原因为：假如在某一瞬间线程 A 和 线程 B 都在调用 getInstance() 方法，此时 instance 对象为 null 值，均能通过 instance == null 的判断。由于实现了 synchronized 加锁机制，线程 A 进入 synchronized 锁定的代码中执行实例创建代码，线程 B 处于排队等待状态，必须等待线程 A 执行完毕后才可以进入 synchronized 锁定的代码。但当 A 执行完毕时线程 B 并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背了单例模式的设计思想，所以要进一步改进，在 synchronized 中再进行一次 instance == null 判断，这种方式称为双重检查锁定（Double-Check Locking）。完整代码如下：\npublic class LazySingleton { private volatile static LazySingleton instance = null; private LazySingleton() { } synchronized public static LazySingleton getInstance() { // 第一重判断 if(instance == null) { // 锁定代码块 synchronized (LazySingleton.class) { // 第二重判断 if(instance == null) { instance = new LazySingleton(); // 创建单例实例 } } } return instance; } } 需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量 instance 之前增加修饰符 volatile，被 volatile 修饰的成员变量可以确保多个线程都能正确处理。由于 volatile 关键字会屏蔽 Java 虚拟机所做的一些代码优化，可能会导致系统的运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方法。\n饿汉式单例类与懒汉式单例类的比较 # 饿汉式单例类在类加载时就将自己实例化，它的优点在于无需考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。从资源利用率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。\n懒汉式单例在第一次使用时创建，无需一直占用系统资源，实现了延迟加载，但是必须处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然设计资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。\n使用静态内部类实现单例模式 # 饿汉式单例和懒汉式单例都存在一些问题，为了克服这些问题，在 Java 语言中可以通过 Initialization on Demand Holder（IoDH）技术来实现单例模式。\n在 IoDH 中，需要在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过 getInstance() 方法返回给外部使用，实现代码如下：\n// Initialization on Demand Holder(IoDH) public class Singleton { private Singleton(){ } // 静态内部类 private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } public static void main(String args[]){ Singleton s1,s2; } } 由于静态单例对象没有作为 Singleton 的成员变量直接实例化，因此类加载时不会实例化 Singleton，第一次调用 getInstance() 时将加载内部类 HolderClass，在该内部类中定义了一个 static 类型的变量 instance，此时会首先初始化这个成员变量，由 Java 虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于 getInstance() 方法没有任何线程锁定，因此其性能不会造成任何影响。\n单例模式优点 # 单例模式提供了对唯一实例的受控访问。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 允许可变数目的实例。基于单例模式可以进行扩展，使用与控制单例对象相似的方法来获得指定个数的实例对象，即节省系统资源，又解决了由于单例对象共享过多有损性能的问题。 单例模式缺点 # 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的指责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。 大部分面向对象语言都提供了垃圾回收技术，因此如果实例化的共享对象长时间不利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这导致共享的单例对象状态的丢失。 单例模式使用环境 # 系统只需要一个实例对象，例如系统要求提供一个唯一的序列化生成器或资源管理器等。 客户调用类的单个实例只允许使用一个公共访问点，除了公共访问点，不能通过其他途径访问该实例。 ","date":"2024-7-17","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater08/","section":"Posts","summary":"","title":"08-单例模式","type":"posts"},{"content":" 原型模式概述 # 在面向对象系统中可以通过复制一个原型对象得到多个与原型对象一模一样的新对象，这就是原型模式的动机。\n原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\nPrototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\n原型模式是一种对象创建型模式，它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。\n需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改不会对原型对象造成任何影响，每一个克隆对象都是相互独立的。\n原型模式结构 # 原型模式结构如下图所示：\n原型模式结构图 由上图可知，原型模式包含以下 3 个角色。\nPrototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是借口，甚至还可以是具体实现类。 ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 Client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法得到多个相同的对象。由于客户类针对抽象原型类 Prototype 编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 浅克隆与深克隆 # 浅克隆\n如果原型对象的成员变量是值类型（基本数据类型），将复制一份给克隆对象；如果原型对象的成员变量是引用类型，将引用对象的地址（内存引用地址）复制一份给克隆对象。\n当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。\n浅克隆示意图 深克隆\n不论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象。也就是除了对象本身，对象所包含的所有成员变量也将被复制。\n深克隆示意图 原型模式实现 # 通过实现方法 # 通用的克隆实现方法是在具体原型的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。\npublic abstract class Prototype { public abstract Prototypr cloen(); } public class ConcretePrototypr extends Prototype { private String attr;\t// 成员变量 public void setAttr(String attr) { this.attr = attr; } public String getAttr() { return this.attr; } // 克隆方法 public Prototype clone() { Prototype prototype = new Prototype(); // 创建新对象 prototype.setAttr(this.attr); return prototype; } } 在客户类中只需要创建一个 ConcretePrototype 对象作为原型对象，然后调用其 cloen() 方法即可得到对象的克隆对象，例如：\n... ConcretePrototype prototype = new ConcretePrototype(); prototype.setAttr(\u0026#34;Sunny\u0026#34;); ConcretePrototype copy = (ConcretePrototype)prototype.clone(); ... 此方法是原型模式的通用实现，它与编程语言本身的特性无关，其他面向编程语言也可以使用这种形式来实现对原型对象的克隆。\nJava 语言中的 clone() 方法和 Cloneable 接口 # 在 Java 语言中，Object 类提供了一个 clone() 方法，可以将一个 Java 对象复制一份。因此在 Java 中可以直接使用 Object 提供的 clone() 方法实现浅克隆。\n能够实现克隆的 Java 类必须实现一个标识接口 Cloneable，表示这个 Java 类支持被复制。如果没有实现这个接口，Java 编译器将抛出一个 CloneNotSupportedException 异常。\npublic class ConcretePrototype implements Cloneable { ... public Prototype clone() { Object object = null; try { object = super.clone();\t// 浅克隆 } catch(CloneNotSuppertedException exception) { System.err.println(\u0026#34;Not support cloneable\u0026#34;); } return (Prototype)object; } ... } 在客户端创建原型对象和克隆对象也很简单。\nPrototype prototype = new Prototype(); Prototype copy = prototype.clone(); Java 语言中的 clone() 方法满足以下几点：\n对任何对象 x，都有 x.clone() != x，即克隆对象和原型对象不是同一个对象。 对任何对象 x，都有 x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样。 如果对象的 x 的 equles() 方法定义恰当，那么 x.clone().equals(x) 应该成立。 为了获取对象的一个克隆，可以直接利用 Object 类的 clone() 方法，具体步骤如下：\n在派生类中覆盖基类的 clone() 方法，并声明为 public。 在派生类的 clone() 方法中调用 super.clone()。 派生类需实现 Cloneable 接口。 此时，Object 类相当于抽象原型类，所有实现了 Cloneable 接口的类相当于具体原型类。\n原型模式应用实例 # 实例说明 # 在使用某 OA 系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。\n试使用原型模式对该 OA 系统中的工作周报创建模块进行改进。\n实例类图 # 通过分析，本实例的结构图如下：\n工作周报创建模块结构图（浅克隆） 实例代码 # Attachment：附件类\npublic class Attachment { private String name; // 附件名 public void setName(String name) { this.name = name; } public String getName() { return this.name; } public void download() { System.out.println(\u0026#34;下载附件，文件名为 \u0026#34; + name); } } WeeklyLog：工作周报类，充当原型角色。在真实环境下该类将比较复杂，考虑到代码的可读性，在此只列出部分与模式相关的核心代码。\npublic class WeeklyLog implements Cloneable { // 为了简化设计和实现，假设一份工作周报中只有一个附件对象，在实际情况中可以包含多个附件，可以通过 List 等集合对象来实现 private Attachment attachment; private String name; private String date; private String content; public Attachment getAttachment() { return attachment; } public void setAttachment(Attachment attachment) { this.attachment = attachment; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } // 使用 clone() 方法实现浅克隆 public WeeklyLog clone() { Object obj = null; try { obj = super.clone(); return (WeeklyLog) obj; } catch (CloneNotSupportedException e) { System.out.println(\u0026#34;不支持复制\u0026#34;); return null; } } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { WeeklyLog log_previous, log_new; log_previous = new WeeklyLog(); // 创建原型对象 Attachment attachment = new Attachment(); // 创建附件对象 log_previous.setAttachment(attachment); // 将附件添加到周报中 log_new = log_previous.clone(); // 调用克隆方法创建克隆对象 // 比较周报 System.out.println(\u0026#34;周报是否相同？\u0026#34; + (log_previous == log_new)); // 比较附件 System.out.println(\u0026#34;附件是否相同？\u0026#34; + (log_previous.getAttachment() == log_new.getAttachment())); } } 结果及分析 # 编译并运行程序，输出结果如下，此方式仅仅实现了对象的浅克隆。\n周报是否相同？false 附件是否相同？true 深克隆解决方案 # 在 Java 语言中可以通过序列化（Serialization）等方式来实现深克隆。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存在于内存中。通过序列化将对象写到一个流中，再从流中将其读出来，可以实现深克隆。需要注意能够实现序列化的对象其类必须实现实现 Serialization 接口。\n下面是用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写入流中，因此两个类均要实现 Serializable 接口，其结构如下图所示：\n工作周报创建模块结构图（深克隆） 修改后的附件类 Attachment 的代码如下：\npublic class Attachment implements Serializable { private String name; // 附件名 public void setName(String name) { this.name = name; } public String getName() { return this.name; } public void download() { System.out.println(\u0026#34;下载附件，文件名为 \u0026#34; + name); } } 工作周报类 WeeklyLog 不再使用 Java 自带的克隆机制，而是通过序列化从头实现对象的深克隆，编写 deepClone() 方法实现深克隆。\npublic class WeeklyLog implements Serializable { private Attachment attachment; private String name; private String date; private String content; public Attachment getAttachment() { return attachment; } public void setAttachment(Attachment attachment) { this.attachment = attachment; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } // 使用序列化技术实现深克隆 public WeeklyLog deepClone() throws IOException, ClassNotFoundException, OptionalDataException { // 将对象写入流中 ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(this); // 将对象从流中取出 ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (WeeklyLog) ois.readObject(); } } 客户端测试类 Client 的代码修改如下：\npublic class Client { public static void main(String[] args) { WeeklyLog log_previous, log_new = null; log_previous = new WeeklyLog(); // 创建原型对象 Attachment attachment = new Attachment(); // 创建附件对象 log_previous.setAttachment(attachment); // 将附件添加到周报中 try { log_new = log_previous.deepClone(); // 调用深克隆方法创建克隆对象 } catch (Exception e) { System.out.println(\u0026#34;克隆失败\u0026#34;); } // 比较周报 System.out.println(\u0026#34;周报是否相同？\u0026#34; + (log_previous == log_new)); // 比较附件 System.out.println(\u0026#34;附件是否相同？\u0026#34; + (log_previous.getAttachment() == log_new.getAttachment())); } } 输出结果如下：\n周报是否相同？false 附件是否相同？false 原型管理器 # 原型管理器（Prototype Manager）将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对爱那个的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中对原型类进行编程，以便扩展。\n带原型管理器的原型模式 典型的原型管理器 PrototypeManager 类的实现代码片段如下：\nimport java.util.*; public class PrototypeManager { private Hashtable prototypeTable = new Hashtable(); // 使用 Hashtable 存储原型对象 public PrototypeManager() { prototypeTable.put(\u0026#34;A\u0026#34;, new ConcretePrototypeA()); prototypeTable.put(\u0026#34;B\u0026#34;, new ConcretePrototypeA()); } public void add(String key, Prototype prototype) { prototypeTable.put(key, prototype); } public Prototype get(String key) { Prototype clone = null; clone = ((Prototype) prototypeTable.get(key)).clone(); // 通过克隆方法创建新对象 return clone; } } 在实际开发中可以将 PrototypeManager 设计为单例类，确保系统中只有一个 PrototypeManager 对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。\n原型模式优点 # 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统没有任何影响。 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个产品等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无需专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（例如恢复到某一历史状态），可辅助实现撤销操作。 原型模式缺点 # 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时需要修改源代码，违背了开闭原则。 在实现深克隆时需要便携较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现比较麻烦。 原型模式适应环境 # 创建新对象成本较大，新对象可以通过复制已有对象来获得。 系统要保存对象的状态，而对象的状态变化很小。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制对象得到新实例可能比使用构造函数构造一个新实例更加方便。 ","date":"2024-7-15","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater07/","section":"Posts","summary":"","title":"07-原型模式","type":"posts"},{"content":" 创造者模式概述 # 建造者模式可以将部分本身和它们得组装过程分开，关注如何一步一步地创建一个包含多个组成部分得复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无需知道其内部的具体构造细节。\n建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\nBuilder Pattern: Separate the construction of a complex object from its representation so that the same construction process can create different representations.\n建造者模式结构 # 建造者模式的结构如下图所示：\n建造者模式结构图 由上图可知，建造者模式包含以下 4 个角色。\nBuilder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是 buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是 getResult()，它们用于返回复杂对象。Builder 既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了 Builder 接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。 Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装备过程。 Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其 construct() 建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制实现），然后通过指挥者类的构造函数或者 Setter 方法将该对象传入指挥者类中。 建造者模式实现 # 在建造者模式的定义中提到了复杂对象，那什么是复杂对象呢？简单来说，复杂对象是指那些包含多个成员变量的对象，这些成员变量也称为部件或零件。一个典型的复杂对象类的代码示例如下：\npublic class Product { private String partA; // 定义部件，部件可以是任意类型，包括值类型和引用类型 private String partB; private String partC; // partA的Getter方法和Setter方法省略 // partB的Getter方法和Setter方法省略 // partC的Getter方法和Setter方法省略 } 在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：\npublic abstract class Builder { // 创建产品对象 protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); // 返回产品对象 public Product getResult() { return product; } } 在抽象类 Builder 中声明了一系列抽象的 buildPartX() 方法，用于创建复杂产品的各个部件，具体创造过程在 ConcreteBuilder 中实现，此外还提供了工厂方法 getResult()，用于返回一个已创建好的完整产品对象。\n在 ConcreteBuilder 中实现了这些 buildPartX() 方法，通过调用 Product 的 setPartX() 方法可以给产品对象的成员变量设值，不同的具体建造者在实现 buildPartX() 方法时有所区别，例如 setPartX() 方法的参数可能不一样，在有些具体建造者类中某些 setPartX() 方法无需实现（提供一个空实现）。而这些对于客户端来说都无需关心，客户端只需知道具体建造者类型即可。典型的具体建造者类代码如下：\npublic class ConcreteBuilder1 extends Builder { public void buildPartA() { product.setPartA(\u0026#34;A1\u0026#34;); } public void buildPartB() { product.setPartB(\u0026#34;B1\u0026#34;); } public void buildPartC() { product.setPartC(\u0026#34;C1\u0026#34;); } } 此外，在建造者模式中还引入了一个指挥者类 Director，该类主要有两个作用：一方面它隔离了客户端与创建过程；另一方面它控制产品对象的创建过程，包括某个 buildPartX() 方法是个被调用以及多个 buildPartX() 方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型便可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。指挥者的示例代码如下：\npublic class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void setBuilder(Builder builder) { this.builder = builder; } // 产品构建和组装方法 public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } 在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法 construct()，在该方法中调用了 builder 对象的构造部件的方法，最后返回一个产品对象。\n对于客户端而言，只需要关心具体建造者的类型，无需关心产品对象的具体组装过程。通常，客户类代码片段如下：\n... Builder builder = new ConcreteBuilder1(); // 可通过配置文件实现 Director director = new Director(builder); Product product = director.construct(); ... 可以通过配置文件来存储具体建造者类 ConcreteBuilder1 的类名，使得在更换新的建造者时无需修改源代码，系统扩展更方便。\n建造者模式与抽象工厂模式都是较为复杂的创建型模式，建造者模式返回一个完整的复杂产品，抽象工厂模式返回一系列相关的产品；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型来指导 Director 类如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个骑车配件生产厂，生成不同类型的骑车配件，那么建造者模式就是一个骑车组装常，通过对配件进行组装返回一辆完整的汽车。\n建造者模式应用实例 # 实例说明 # 某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。\n作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、脸型等多个组成部分，不同类型的游戏角色，其性别、脸型、服装、发型等外部特征都有所差异，例如“天使”拥有着美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”及其丑陋，留着光头并穿着一件刺眼的黑衣。\n无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。\n试使用建造者模式来实现游戏角色的创建。\n实例类图 # 通过分析，本实例的结构如图所示：\n游戏角色创建结构图 实例代码 # Actor：游戏角色类，充当复杂产品对象。考虑到代码的可读性，在此只列出部分成员变量，且成员变量的类型均为 String，在真实情况下，有些成员变量的类型需要自定义。\npublic class Actor { private String type; // 角色类型 private String sex; // 性别 private String face; // 脸型 private String costume; // 服装 private String hairstyle; // 发型 public void setType(String type){ this.type = type; } public void setFace(String face){ this.face = face; } public void setSex(String sex) { this.sex = sex; } public void setCostume(String costume){ this.costume = costume; } public void setHairstyle(String hairstyle) { this.hairstyle = hairstyle; } public String getType() { return type; } public String getSex() { return sex; } public String getFace() { return face; } public String getCostume() { return costume; } public String getHairstyle() { return hairstyle; } } ActorBuilder：游戏角色创建者，充当抽象建造者。\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 工厂方法，返回一个完整的游戏角色对象 public Actor createActor() { return actor; } } HeroBuilder：英雄角色建造者，充当具体建造者。\npublic class HeroBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;英雄\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;男\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;英俊\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;盔甲\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;飘逸\u0026#34;); } } AngleBuilder：天使角色建造者，充当具体建造者。\npublic class AngleBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;天使\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;女\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;漂亮\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;白裙\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;披肩长发\u0026#34;); } } DevilBuilder：恶魔角色建造者，充当具体建造者。\npublic class DevilBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;恶魔\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;妖\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;丑陋\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;黑衣\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;光头\u0026#34;); } } ActorController：角色控制器，充当指挥者。\npublic class ActorController { // 逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); actor = ab.createActor(); return actor; } } 配置文件 config.xml，在配置文件中存储了具体建造者类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.builder.AngleBuilder\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\n// 将 XML 工具类提取到 utils 包中，传入config.xml 文件路径，方便使用 package com.wangyq.utils; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import java.io.File; public class XMLUtil { public static Object getBean(String filePath) { try { // 创建 DOM 文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(filePath)); // 获取包含类名的文本结点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { ActorBuilder ab; // 针对抽象建造者编程 ab = (ActorBuilder) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/builder/config.xml\u0026#34;); // 反射生成具体建造者对象 ActorController ac = new ActorController(); Actor actor; actor = ac.construct(ab); // 通过指挥者创建完整的建造者对象 String type = actor.getType(); System.out.println(type + \u0026#34;的外观：\u0026#34;); System.out.println(\u0026#34;性别：\u0026#34; + actor.getSex()); System.out.println(\u0026#34;面容：\u0026#34; + actor.getFace()); System.out.println(\u0026#34;服装：\u0026#34; + actor.getCostume()); System.out.println(\u0026#34;发型：\u0026#34; + actor.getHairstyle()); } } 结果及分析 # 编译并运行程序，输出结果如下：\n天使的外观： 性别：女 面容：漂亮 服装：白裙 发型：披肩长发 如果需要更换具体角色建造者，只需要修改配置文件即可。\n当需要增加新的具体角色建造者时只需要将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件，原有代码无需修改，完全符合开闭原则。\n指挥者类的深入讨论 # 指挥者类 Director 是建造者模式的重要组成部分，简单的 Director 类用于指导具体建造者如何构建产品，它按一定次序调用 Builder 的 buildPartX() 的方法，控制调用的先后次序，并向客户端返回一个完整的产品对象。下面讨论几种 Director 的变化形式。\n省略 Director # 在有些情况下，为了简化系统结构，可以将 Director 和抽象建造者 Builder 进行合并，在 Builder 中提供逐步构建复杂产品对象的 construct() 方法。由于 Builder 类通常为抽象类，因此可以将 construct() 方法定义为静态（static）方法，以便客户端能够直接调用。如果将游戏角色实例中的指挥者类 ActorController 省略，ActorBuilder 类的代码修改如下：\npublic abstract class ActorBuilder { protected static Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public static Actor construct(ActorBuilder ab) { ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); return actor; } } 此时对应的客户端代码也将发生修改，代码片段如下：\n... ActorBuilder ab; ab = (ActorBuilder) XMLUtil.getBean(); Actor actor; actor = ActorBuilder.construct(ab); ... 除此之外，还有一种更简单的处理方式，可以将 construct() 方法中的参数去掉，直接在 construct() 方法中调用 buildPartX() 方法，代码如下：\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public Actor construct() { this.buildType(); this.buildSex(); this.buildFace(); this.buildCostume(); this.buildHairstyle(); return actor; } } 客户端代码片段如下：\n... ActorBuilder ab; ab = (ActorBuilder) XMLUtil.getBean(); Actor actor; actor = ab.construct(); ... 此时，construct() 方法定义了 buildPartX() 方法的调用次序，为 buildPartX() 方法的执行提供了一个流程模板，这与在后边要学习的模板方法非常类似。\n以上两种对 Director 类的省略方法都不影响系统的灵活性和可扩展性，同时还简化了系统结构，但加重了抽象建造者类的职责。如果 construct() 方法较为复杂，待构建产品的组成部分比较多，建议还是将 construct() 方法单独封装在 Director 中，这样更符合单一职责原则。\n钩子方法的引入 # 钩子方法（Hook Method）用来控制是否对某个 buildPartX() 进行调用。\n钩子方法的返回类型通常为 boolean 类型，方法名一般为 isXXX()，钩子方法定义在抽象建造者类中。例如可以在游戏角色的抽象建造者类 ActorBuilder 中定义一个方法 isBareheaded()，用于判断某个角色是否为“光头（Bareheaded）”，在 ActorBuilder 为之提供一个默认实现，代码如下：\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 钩子方法 public boolean isBareheaded() { return false; } public Actor createActor() { return actor; } } 如果某个角色无需构建头发部件，例如“恶魔”，则对应的具体建造器 DevilBuilder 将覆盖 isBareheaded() 方法，并将返回值改为 true，代码如下：\npublic class DevilBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;恶魔\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;妖\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;丑陋\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;黑衣\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;光头\u0026#34;); } // 覆盖钩子方法 public boolean isBareheaded() { return true; } } 同时，指挥者类 ActorController 的代码修改如下：\npublic class ActorController { // 逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); // 通过钩子方法来控制产品的构建 if(!ab.isBareHeaded()) { ab.buildHairstyle(); } actor = ab.createActor(); return actor; } } 当在客户端代码中置顶具体建造者类型并通过指挥者来实现产品的逐步构建时，将调用钩子方法 isBareheaded() 来判断游戏角色是否有头发，如果 isBareheaded() 方法返回 true，即没有头发，将跳过构建发型的方法 buildHairstyle()，否则将执行 buildHairstyle() 方法。\n通过引入钩子方法，可以在 Director 中对复杂产品的构建进行精细的控制，不仅指定 buildPartX() 方法的执行顺序，还可以控制是否需要执行某个 buildPartX() 方法。\n建造者模式优点： # 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因为可以很方便地替换具体建造者或增加新的具体建造，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。 建造者模式缺点： # 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。 建造者模式适用环境 # 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类将创建过程封装在指挥者类中，而不在建造者和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 ","date":"2024-7-12","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater06/","section":"Posts","summary":"","title":"06-建造者模式","type":"posts"},{"content":" 产品等级结构和产品族 # 工厂方法模式通过引入工厂等级结构解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个具体工厂只有一个或者一组重载的工厂方法，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。有时候可能需要一个工厂可以提供多种产品对象，而不是单一的产品对象，此时可以考虑将一些相关的产品组成一个“产品族”，由一个工厂来统一生产。\n为了更好地理解抽象工厂模式，先引入两个概念：\n产品等级结构：产品等级结构即产品的继承结构。 产品族：在抽象工厂模式中，产品族是指由同一工厂生产的位于不同产品等级结构中的一组产品。 产品等级结构和产品族示意图如下图所示：\n产品族与产品等级结构示意图 在上图中一共包含了 3 个产品族，分属于 3 个不同的产品等级结构，只要指明一个产品所处的产品族以及它所属的等级结构就可以唯一确定这个产品。\n抽象工厂模式概述 # 当系统所提供的工厂生产的具体产品不是一个见到那的对象，而是多个不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。\n抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构的一个产品族中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如下图所示：\n抽象工厂模式示意图 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。\n抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\nAbstract Factory Pattern: Provide an interface for creating familes of related or dependent objects without specifying their concrete classes.\n抽象工厂模式又称为工具（Kit）模式，它是一种对象创建型模式。\n抽象工厂模式结构 # 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图所示：\n抽象工厂模式结构图 由上图可知，抽象工厂模式包含以下 4 个角色：\nAbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生产一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 抽象工厂模式实现 # 在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以时接口，也可以是抽象类或者具体类。其典型代码如下：\npublic interface AbstractFactory { public AbstractProductA createProductA(); // 工厂方法一 public AbstractProductB createProductB(); // 工厂方法二 } 具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下：\npublic class ConcreteFactory1 extends AbstractFactory { // 工厂方法一 public AbstractProductA createProductA() { return new ConcreteProductA1(); } // 工厂方法二 public AbstractProductB createProductB() { return new ConcreteProductB1(); } } 与工厂方法模式一样，抽象工厂模式也可以为每一种产品提供一组重载的工厂方法，以不同的方式来创建产品对象。\n抽象工厂模式应用实例 # 实例说明 # 某软件公司要开发一套界面皮肤库，可以对基于 Java 的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天（Spring）风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天（Summer）风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：\n界面皮肤库结构示意图 该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。\n实力类图 # 通过分析，本实例的结构图如下图所示：\n实例代码 # Button：按钮接口，充当抽象产品。\npublic interface Button { public void display(); } SpringButton：Spring 按钮类，充当具体产品。\npublic class SpringButton implements Button{ @Override public void display() { System.out.println(\u0026#34;显示浅绿色按钮。\u0026#34;); } } SummerButton：Summer 按钮类，充当具体产品。\npublic class SummerButton implements Button { @Override public void display() { System.out.println(\u0026#34;显示浅蓝色按钮。\u0026#34;); } } TextField：文本框接口，充当抽象产品。\npublic interface TextField { public void display(); } SpringTextField：Spring 文本框类，充当具体产品。\npublic class SpringTextField implements TextField{ @Override public void display() { System.out.println(\u0026#34;显示绿色边框文本框。\u0026#34;); } } SummerTextField：Summer 文本框类，充当具体产品。\npublic class SummerTextField implements TextField{ @Override public void display() { System.out.println(\u0026#34;显示蓝色边框文本。\u0026#34;); } } ComboBox：组合框接口，充当抽象产品。\npublic interface ComboBox { public void display(); } SpringComboBox：Spring 组合框类，充当具体产品。\npublic class SpringComboBox implements ComboBox{ @Override public void display() { System.out.println(\u0026#34;显示绿色边框组合框。\u0026#34;); } } SummerComboBox：Summer 组合框类，充当具体产品。\npublic class SummerComboBox implements ComboBox{ @Override public void display() { System.out.println(\u0026#34;显示蓝色边框组合框。\u0026#34;); } } SkinFactory：界面皮肤工厂接口，充当抽象工厂。\npublic interface SkinFactory { public Button createButton(); public TextField createTextField(); public ComboBox createComboBox(); } SpringSkinFactory：Spring 皮肤工厂，充当具体工厂。\npublic class SpringSkinFactory implements SkinFactory{ @Override public Button createButton() { return new SpringButton(); } @Override public TextField createTextField() { return new SpringTextField(); } @Override public ComboBox createComboBox() { return new SpringComboBox(); } } SummerSkinFactory：Summer 皮肤工厂，充当具体工厂。\npublic class SummerSkinFactory implements SkinFactory { @Override public Button createButton() { return new SummerButton(); } @Override public TextField createTextField() { return new SummerTextField(); } @Override public ComboBox createComboBox() { return new SummerComboBox(); } } 配置文件 config.xml，在配置文件中存储了具体工厂类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.abstractfactory.SpringSkinFactory\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\npublic class XMLUtil { //该方法用于从XML配置文件中提取具体类类名， 并返回一个实例对象 public static Object getBean() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/abstractfactory/config.xml\u0026#34;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { // 使用抽象层定义 SkinFactory factory; Button bt; TextField tf; ComboBox cb; factory = (SkinFactory) XMLUtil.getBean(); bt = factory.createButton(); tf = factory.createTextField(); cb = factory.createComboBox(); bt.display(); tf.display(); cb.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n显示浅绿色按钮。 显示绿色边框文本框。 显示绿色边框组合框。 如果需要更换皮肤，只需要修改配置文件即可。\n如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件中的具体工厂类名即可使用新的皮肤，原有代码无需修改，符合开闭原则。\n开闭原则的倾斜性 # 在抽象工厂模式中增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。开闭原则要求对扩展开放，对修改关闭，通过扩展达到增强其功能的目的，对于涉及多个产品族与多个产品等级结构的系统，其功能增强包括两个方面。\n增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无需做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，它以一种倾斜的方式来满足开闭原则，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够考虑全面，不会在设计完成之后再向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n抽象工厂模式优/缺点与使用环境 # 抽象工厂模式是工厂方法模式的进一步眼神，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和 API 类库的设计中。\n抽象工厂模式优点 # 抽象工厂模式隔离了具体类的生产，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对榕溪，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无需修改已有系统，符合开闭原则。 抽象工厂模式缺点 # 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不变，违背了开闭原则。\n抽象工厂模式适用环境 # 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无需关系对象的创建过程，将对象的创建和使用解耦。 系统中有多于一个的产品族，而每次只是用其中某一产品族。可以通过配置文件等方式来使用户能够动态改变产品族，也可以很方便地增加新的产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 ","date":"2024-7-10","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater05/","section":"Posts","summary":"","title":"05-抽象工厂模式","type":"posts"},{"content":" 工厂方法模式概述 # 简单工厂模式在新增一个类型时，需要修改工厂类的代码，使得整个设计在一定程度上违反了开闭原则。工厂方法模式通过引入抽象的工厂类，使得它在新增类型时不需要修改具体的工厂类就可以创建，让系统更加符合开闭原则。\n在工厂方法模式中不再提供一个同一个的工厂类来创建所有的产品对象，二是针对不同的产品提供不同的工厂，系统提供一个与产品等级接口对应的工厂等级结构。\n工厂方法模式：定义一个用于创建实例对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。\nFactory Method Pattern: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n工厂方法模式简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。工厂方法模式时一种类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n工厂方法模式结构 # 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。结构图如下所示：\n工厂方法模式结构图 由上图可知，工厂方法模式包含以下 4 个角色：\nProduct（抽象产品）：它时定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品一一对应。 Factory（抽象工厂）：在抽象工厂类中声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 工厂方法模式实现 # 与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下：\npublic interface Factory { public Product factoryMethod(); } 在抽象工厂中声明了工厂方法单并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。其典型代码如下：\npublic class ConcreteFactory implement Factory { public Product factoryMethod() { return new ConcreteProduct(); } } 在实际使用时，具体工厂类在实现工厂方法时处理创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件都能。\n在客户端代码中，开发人员只需关心工厂类接口，不同的具体工厂可以创建不同的产品。典型的客户端代码片段如下：\n... Factory factory; factory = new ConcreteFactory(); // 可通过配置文件与反射机制实现 Product product; product = factory.factoryMethod(); ... 可以通过配置文件来存储具体工厂类 ConcreteFactory 的类名，再通过反射机制创建具体工厂对象，在更换新的具体工厂时无需修改源代码，系统扩展更方便。\n举个例子 # 实例说明 # 某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置由严格的先后顺序，否则可能会发生记录失败。\n为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统（注：在 Java 中常用的日志记录工具有 SLF4J、Log4j、GCLogViewer、Logstash 等）。\n实例类图 # 通过分析，本实例结构如下图所示：\n日志记录器结构图 Logger 接口充当抽象产品，其子类 FileLogger 和 DatabaseLogger 充当具体产品，LoggerFactory 接口充当抽象工厂，其子类 FileLoggerFactory 和 DatabaseLoggerFactory 充当具体工厂。\n实例代码 # Logger：日志记录器接口，充当抽象产品角色。\npublic interface Logger { public void writeLog(); } DatabaseLogger：数据库日志记录器，充当具体产品角色。\npublic class DatabaseLogger implements Logger { @Override public void writeLog() { System.out.println(\u0026#34;数据库日志记录。\u0026#34;); } } FileLogger：文件日志记录器，充当具体产品角色。\npublic class FileLogger implements Logger { @Override public void writeLog() { System.out.println(\u0026#34;文件日志记录。\u0026#34;); } } LoggerFactory：日志记录工厂接口，充当抽象工厂角色\npublic interface LoggerFactory { public Logger createLogger(); // 抽象工厂方法 } DatabaseLoggerFactory：数据库日志记录器工厂类，充当具体工厂角色。\npublic class DatabaseLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 连接数据库，代码省略 // 创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } } FileLoggerFactory：文件日志记录器工厂类，充当具体工厂角色。\npublic class FileLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 创建文件日志记录器对象 Logger logger = new FileLogger(); // 创建文件，代码省略 return logger; } } Cilent：客户端测试类。\npublic class Client { public static void main(String[] args) { LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); // 可引入配置文件和反射机制实现 logger = factory.createLogger(); logger.writeLog(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n文件日志记录。 如果需要增加并使用新的日志记录器，只需要对应增加一个新的具体工厂类，然后在客户端代码中修改具体工厂类的类名，原有类库的源代码无需做任何修改。\n通过引入配置文件并使用反射机制可以实现在不修改客户端代码的基础上更换具体工厂类，让系统用更加符合开闭原则，具备更好的灵活性和可扩展性。\n反射机制与配置文件 # 上面的实例中，在更换日志记录器时需要修改客户端代码，对于客户端而言并不符合开闭原则，本节将介绍如何在不修改客户端代码的基础上更换或增加新的日志记录方式。\n在实际应用开发中，可以对具体工厂类的实例化过程进行修改，在客户端代码中不直接使用 new 关键字来创建工厂对象，而是通过 Java 反射机制结合配置文件（例如 XML 文件）来生成具体工厂对象。\nJava 反射机制\nJava 反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。\n// 通过类名生成实例对象并将其返回 Class c = Class.forName(\u0026#34;java.lang.String\u0026#34;); Object obj = c.newInstence(); return obj; 配置文件\n软件系统的配置文件通常为 XML 文件，可以使用 DOM（Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）等技术来处理 XML 文件。\n在软件开发中可以把类名存储到 XML 配置文件中，再读取配置文件获取类名字符串，然后通过 Java 反射机制来创建对象。\n\u0026lt;!-- config.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;designpatterns.factorymethod.FileLoggerFactory\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; 为了读取该配置文件，并通过存储再其中的类名字符串反射生成对象，可以创建一个工具类 XMLUtil，其详细代码如下：\nimport org.w3c.dom.*; import javax.xml.parsers.*; import java.io.File; public class XMLUtil { // 该方法用于从 XML 配置文件中提取具体类的类名，并返回一个实例对象 public static Object getBean() { try { // 创建 DOM 文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/factorymethod/config.xml\u0026#34;)); // 获取包含类名的文本结点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } public static void main(String[] args) { Object bean = getBean(); String simpleName = bean.getClass().getSimpleName(); System.out.println(simpleName); } } 有了 XMLUtil 类之后，可以对日志记录器的客户端代码进行修改，不再直接使用 new 关键字来创建具体的工厂类，而是将 具体 工厂列的类名存储在 XML 文件中，再通过 XMLUtil 类的静态工厂方法 getBean() 进行对象的实例化，将代码修改如下：\npublic class Client { public static void main(String[] args) { LoggerFactory factory; Logger logger; factory = (LoggerFactory) XMLUtil.getBean(); // getBean() 的返回类型为 Object，需要进行强制类型转换 logger = factory.createLogger(); logger.writeLog(); } } 在引入 XMLUtil 类和 XML 配置文件之后，如果需要增加一种新类型的日志记录方式，只需要执行以下 4 个步骤：\n新的日志记录器需要继承抽象日志记录器 Logger； 对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂 LoggerFactory，并实现其中的工厂方法 createLogger()，设置好初始化参数和环境变量，返回具体日志记录器对象。 修改配置文件 config.xml，用新增的具体日志记录器工厂类的类名字符串替换原有工厂类的类名字符串。 编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合开闭原则。 工厂方法的重载 # 在某些情况下，可以通过多种方式来初始化同一个产品类。此时可以提供一个重载的工厂方法，以不同的方式对产品对象进行创建。对于同一个具体工厂而言，无论使用哪个工厂方法，所创建的产品类型均要相同。重载的工厂方法结构图如下图所示：\n重载的工厂方法结构图 引入重载方法后，抽象工厂类 LoggerFactory 的代码修改如下：\npublic interface LoggerFactory { public Logger createLogger(); // 抽象工厂方法 public Logger createLogger(String args); public Logger createLogger(Object obj); } 具体工厂类 DatabaseLoggerFactory 的代码修改如下：\npublic class DatabaseLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 使用默认方式连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } @Override public Logger createLogger(String args) { // 使用参数 args 作为连接字符串来连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } @Override public Logger createLogger(Object obj) { // 使用封装在参数 obj 中的连接字符串来连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 使用封装在参数 obj 中的数据来初始化数据库日志记录器，代码省略 return logger; } } // 其他具体工厂类代码省略 工厂方法的隐藏 # 有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时在工厂类中直接调用产品类的业务方法，客户端无需调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。\n如果对客户端隐藏工厂方法，那么日志记录器结构图可修改为如下图所示\n隐藏工厂方法后的日志记录器结构图 抽象工厂类的代码修改如下：\n// 将接口改为抽象类 public abstract class LoggerFactory { // 在工厂类中直接调用日志记录器的业务方法 writeLog() public void writeLog() { Logger logger = this.createLogger(); logger.writeLog(); } public abstract Logger createLogger(); } 客户端代码修改如下：\npublic class Client { public static void main(String[] args) { LoggerFactory factory; factory = (LoggerFactory) XMLUtil.getBean(); factory.writeLog(); // 直接使用工厂对象来调用产品对象的业务方法 } } 工厂方面模式优/缺点与适应环境 # 工厂方法模式优点 # 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部。 使用工厂方法模式的另一个优点是在系统中加入新产品时无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他大的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样系统的可扩展性也就变的非常好，完全符合开闭原则。 工厂方法模式的缺点 # 在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成增加，在一定程度上增加了系统的复杂性，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 工厂方法模式适用环境 # 客户端不知道它所需要的对象的类。 抽象工厂类通过其子类来指定创建哪个对象。 ","date":"2024-7-8","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater04/","section":"Posts","summary":"","title":"04-工厂方法模式","type":"posts"},{"content":" 创建型模式 # 创建型模式（Creational Pattern）关注对象的创建过程，是一类常用的设计模式。创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例和创建细节，让用户在使用对象的时候无需关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。\n创建型模式一览表\n模式名称 定义 学习难度 使用频率 简单工厂模式（Simple Factory Pattern） 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类 ⭐⭐ ⭐⭐⭐ 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 ⭐⭐ ⭐⭐⭐⭐⭐ 抽象工厂方法（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 ⭐⭐⭐⭐ ⭐⭐⭐⭐⭐ 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 ⭐⭐⭐⭐ ⭐⭐ 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象 ⭐⭐⭐ ⭐⭐⭐ 单例模式（Singleton Pattern） 确保一个类只有一个实例 ⭐ ⭐⭐⭐⭐ 简单工厂模式概述 # 简单工厂模式的设计思想和实现过程都比较简单，其基本实现流程如下：\n首先将需要创建的各种不同产品对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需要调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。\n简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式。\n简单工厂模式结构 # 简单工厂模式包含以下 3 个角色\nFactory（工厂角色）：工厂角色即工厂类，他是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。 Product（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 简单工厂模式结构图 简单工厂模式实现 # 在简单工厂模式中客户端通过工厂类来创建一个产品类的实例，而无须直接使用 new 关键字来创建对象，它是工厂模式家族中最简单的一员。\n在使用简单工厂模式时首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，一共不同的具体产品来实现。典型的抽象产品类代码的如下：\npublic abstract class Product { // 所有产品类的公共业务方法 public void methodSame() { // 公共方法的实现 } // 声明抽象业务方法 public abstract void methodDiff(); } 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。典型的具体产品类的代码如下：\npublic class ConcreteProduct extends Product{ // 实现业务方法 public void methodDiff() { // 业务方法的实现 } } 简单工厂模式的核心是工厂类，在没有工厂类之前客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后客户端可以通过工厂类来创建产品，在简单工厂模式中工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。典型的工厂的代码如下：\npublic class Factory { // 静态工厂方法 public static Product getProduct(String arg){ if (arg.equalsIngoreCase(\u0026#34;A\u0026#34;)){ product = new ConcreateProductA(); // 初始化设置 product } else if (arg.equalsIgnoreCase(\u0026#34;B\u0026#34;)){ product = new ConcreateProductB(); // 初始化设置 product } return product; } } 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：\npublic class Client{ public static void main(String args[]){ Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;); // 通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); } } 举个例子 # 实例说明： # 某软件公司要基于 Java 语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart)等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。\n现使用简单工厂模式来设计图表库。\n实例类图 # 图表库结构图 上图中，Chart 接口充当抽象产品类，其子类 HistogramChart、PieChart 和 LineChart 充当具体产品类，ChartFactory 充当工厂类。\n实例代码 # Chart：抽象图表接口，充当抽象产品类。\npublic interface Chart { public void display(); } HistogramChart：柱状图类，充当具体产品类。\npublic class HistogramChart implements Chart { public HistogramChart() { System.out.println(\u0026#34;创建柱状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示柱状图！\u0026#34;); } } PieChart：饼状图类，充当具体产品类。\npublic class PieChart implements Chart { public PieChart() { System.out.println(\u0026#34;创建饼状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示饼状图！\u0026#34;); } } LineChart：折线图类，充当具体产品类。\npublic class LineChart implements Chart { public LineChart() { System.out.println(\u0026#34;创建折线图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示折线图！\u0026#34;); } } ChartFactory：图表工厂类，充当工厂类。\npublic class ChartFactory { // 静态工厂方法 public static Chart getChart(String type) { Chart chart = null; if (type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { chart = new HistogramChart(); System.out.println(\u0026#34;初始化设置柱状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { chart = new PieChart(); System.out.println(\u0026#34;初始化设置饼状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { chart = new LineChart(); System.out.println(\u0026#34;初始化设置折线图！\u0026#34;); } return chart; } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Chart chart; chart = ChartFactory.getChart(\u0026#34;histogram\u0026#34;); // 通过静态方法创建产品 chart.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n创建柱状图！ 初始化设置柱状图！ 显示柱状图！ 在客户端测试类中使用工厂类 ChartFactory 的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可。\n但是创建具体 Chart 对象时必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象，客户端代码需要重新编译，这对于客户端而言违反了开闭原则。\n一种常用的解决方案，可以将静态工厂方法的参数存储在 XML 等配置文件中，通过工具类读取配置文件中的字符串参数，更换图表时只需要改配置文件即可。\n简单工厂模式的简化 # 有时候，为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品中，如下图所示：\n简化的简单工厂模式 简单工厂模式优/缺点与适应环境 # 优点 # 工厂创建对象，客户端使用对象，实现了对象创建和使用的分离； 客户端无需知道创建的具体产品类的类名，可以在一定程度上减少使用者的记忆量； 通过引入配置文件，可以在不修改客户端代码的情况下更换和增加新的具体类，在一定程度上提高了系统的灵活性。 缺点 # 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响； 使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度； 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑。 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 # 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂； 客户端只知道传入工厂类的参数，不关心如何创建对象。 ","date":"2024-7-5","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater03/","section":"Posts","summary":"","title":"03-简单工厂模式","type":"posts"},{"content":" 面向对象的设计原则概述 # 衡量软件质量的重要属性：\n可维护性（Maintainability）\n指软件能够被理解、改正、适应及扩展的难易程度；\n可复用性（Reusability）\n指软件能够被重复使用的难易程度。\n最常见的 7 个面向对象设计原则：\n设计原则名称 定义 使用频率 单一职责原则（Single Responsibility Principle，SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 ⭐⭐⭐⭐ 开闭原则（Open-Close Principle，OCP） 软件实体应带对扩展开放，对修改关闭 ⭐⭐⭐⭐⭐ 里氏代换原则（Liskov Substitution Principle，LSP） 所有引用基类的地方必须透明地使用其子类的对象 ⭐⭐⭐⭐⭐ 依赖倒转原则（Dependence Inversion Principle，DIP） 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 ⭐⭐⭐⭐⭐ 接口隔离原则（Interface Reuse Principle，IRP） 客户端不应该依赖那些它不需要的接口 ⭐⭐ 合成复用原则（Composite Reuse Principle，CRP） 优先使用对象组合，而不是通过继承来达到复用的目的 ⭐⭐⭐⭐ 迪米特法则（Law of Demeter，LoD） 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 ⭐⭐⭐ 单一职责原则 # 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。\nSingle Responsibility Principle(SRP): Every object should hava a single responsibility, and that responsibility should be entirely encapsulated by the class.\n单一职责原则是实现高内聚、低耦合的指导方阵，它是最简单但又是最难运行的原则。\n例如：一个类，既要连接数据库，又要对表格进行操作，又要生成相关的统计图表。对于这个类，我们可以按照单一职责原则，将其拆分成三个类：用于连接数据库的工具类，用于操作数据库表的 DAO 类，用于生成图表并展示的类。\n开闭原则 # 开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。\n开闭原则：软件实体应当对扩展开放，对修改关闭。\nOpen-Close Principle(OCP): Software entities should be open for extension, but closed for modification.\n开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。\n为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。\n很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。\n里氏代换原则 # 以 Barbara Liskov（芭芭拉·利斯科夫）教授的姓氏命名，其严格表述如下：如果对每一个类型为 S 的对象 o1 都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换 o2 时程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。\n这个原始的定义不太容易理解，一般使用它的另一个通俗版定义：\n里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象。\nLiskov Subsitution Principle (LSP): Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\n里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。\n里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。\n依赖倒转原则 # 依赖倒转原则是面向对象设计的主要实现机制之一，是系统抽象化的具体实现。\n依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\nDependence Inversion Principle(DIP): High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.\n简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。\n依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，疯狗则将无法调用到在子类中增加的新方法。\n在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有的系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。\n在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependence Injection, DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，采用抽象的形式来注入所依赖的对象。常用的注入方式有 3 种，分别是构造注入、设值（Setter） 注入和接口注入。\n构造注入是指通过构造函数来传入具体类的对象。 设值注入是指通过 Setter 方法来传入具体类的对象。 接口注入是指通过在接口种声明的业务方法来传入具体类的对象。 大多数情况下，开闭原则、里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。\n接口隔离原则 # 接口隔离原则：客户端不应该依赖那些它不需要的接口。\nInterface Segregation Principle(ISP): Client should not be forced to depend upon interfaces that they do not use.\n当一个接口太大时需要将他分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。\n在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，在接口中仅包含为某一类用户定值的方法即可，不应该强迫客户依赖于那些他们不用的方法。\n合成复用原则 # 合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：\n合成复用原则：优先使用对象组合，而不是通过继承来达到复用的目的。\nComposite Reuse Principle(CRP): Favor composition of objects over inheritance as a reuse mechanism.\n在复用时尽量使用组合/聚合关系（关联关系），少用继承。\n如果两个类之间使“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可以使用继承。\n迪米特法则 # 迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP），其定义如下：\n迪米特法则：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\nLaw of Demeter(LoD): Each unit should have only limited knowledge about other units: only units \u0026ldquo;closely\u0026rdquo; related to the current unit.\n迪米特法则要求一个软件实体应当尽可能地与其他实体发生相互作用。\n迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don\u0026rsquo;t talk to strangers.）、只与你的直接朋友通信（Talk only to your immediate friends.）等。在迪米特法则中，对于一个对象，其朋友包括以下几类：\n当前对象本身（this）。 以参数形式传入到当前对象方法中的对象。 当前对象的成员对象。 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。 当前对象所创建的对象。 应用迪米特法则，可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。通过引入一个合理的“第三者”来降低现有对象之间的耦合度。\n将迪米特法则应用到系统设计中应注意以下几点：\n在类的划分上，尽量创建松耦合的类，有利于复用，松耦合的类一旦被修改，不会对关联的类造成太大影响。 在类的结构设计的上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 ","date":"2024-7-4","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater02/","section":"Posts","summary":"","title":"02-面向对象设计原则","type":"posts"},{"content":" 设计模式的诞生与发展 # 模式的诞生与定义 # 模式（Pattern）起源于建筑业而非软件业，模式之父 \u0026ndash; Christopher Alexander 博士。\n模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案.\nA pattern is a successful or efficient solution to a recurring problem within a context.\n当一个领域逐渐成熟的时候自然会有很多模式。模式是一种直到，在一个良好的指导下有助于设计一个优良的解决方案，达到事半功倍的效果，而且会的到解决问题的最佳办法。\n最早将模式的思想引入软件工程学的是 1991-1992 年以“四人组”（Gang of Four，GOF，分别是 Erich Gamma、Richard helm、Ralph Johnson 和 John Vlissides）自称的 4 位著名软件工程学者。\nGoF 将模式的概念引入软件工程领域，这标志着软件模式的诞生。\n软件模式并非仅仅限于设计模式，还包括架构模式、分析模式和过程模式等。\n软件模式是在一定条件下的软件开发问题及其解法。软件模式的基本结构由 4 个部分构成，即问题描述、前提条件（环境或约束条件）、解法和效果，如下图所示。\n设计模式的定义与分类 # 设计模式的定义 # 设计模式（Design Pattern）是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解并且提高代码的可靠性。\nGoF 对设计模式的定义如下：\n设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定值的解决方案，该方案描述了对象和类之间的相互作用。\nDesign patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.\n设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素有以下 4 个。\n模式名称（Pattern Name）\n通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的。\n问题（Problem）\n问题描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。在对问题进行描述的同时实际上就确定了模式所对应的使用环境以及模式的使用动机。\n解决方案（Solution）\n结局方案描述了设计模式的组成成分，以及这些组成成分的相互关系、各自的职责和协作方式。不针对具体问题，使用抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。\n效果（Consequences）\n效果描述了模式应用的效果以及在使用模式时应权衡的问题。没有一个解决方案是百分之百完美的，在使用设计模式时需要进行合理的评价和选择。\n设计模式的分类 # 设计模式一般有两种分类方式：\n根据目的分类\n分为创建型（Creational）、结构型（Structural）和行为型（Behavioral）三类。\n根据范围分类\n分为类模式和对象模式两种。\nGoF 设计模式简介 # GoF 的 23 种模式一览表 # 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式模板方法模式 对象模式 抽象工厂模式建造者模式原型模式单例模式 （对象）适配器模式桥接模式组合模式装饰模式外观模式享元模式代理模式 职责链模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式 GoF 的 23 种设计模式的简要说明 # 模式类别 模式名称 模式说明 创建型模式（Creational Patterns） 抽象工厂模式（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样得构建过程可以创建不同的表示 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来后创建新的对象 单例模式（Singleton Pattern） 确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例 结构型模式（Structural Patterns） 适配器模式（Adapter Pattern） 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作 桥接模式（Bridge Pattern） 将抽象部分与它的实例部分解耦，使得两者都能够独立变化 组合模式（Composite Pattern） 组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象 装饰模式（Decorator Pattern） 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供一种比使用子类更加灵活的替代方案 外观模式（Façade Pattern） 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 享元模式（Flyweight Pattern） 运用共享技术有效地支持大量细粒度对象的复用 代理模式（Proxy Pattern） 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问 行为型模式（Behavioral Patterns） 职责链模式（Chain of Responsibility Pattern） 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止 命令模式（Command Pattern） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示来解释语言中的句子 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示 中介者模式（Mediator Pattern） 定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 备忘录模式（Memento Pattern） 在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以将对象恢复到原先保存的状态 观察者模式（Observer Pattern） 定义对象直接按的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知被自动更新 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 策略模式（Strategy Pattern） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户而变化 模板方式模式（Template Method Pattern） 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 访问者模式（Visitor Pattern） 表示一个作用与某对象结构中的各个元素的操作。访问者模式可以在不改变各元素的类的前提下定义作用于这些元素的新操作 设计模式的优点 # 设计模式融合了众多专家的经验，并以一种标准的形式供广大开发人员所用，它提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。 设计模式使人们可以更加简单、方便地复用成功的设计和体系结构，将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 设计模式使得设计方案更加灵活，且易于修改。 设计模式的使用将提高软件系统的开发效率和软件质量，并且在一定程度上节约设计成本。 设计模式有助于初学者更深入地理解面向对象思想，一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码，另一方面还可以提高软件的设计水平和代码质量。 ","date":"2024-7-3","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chapter01/","section":"Posts","summary":"","title":"01-设计模式概述","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/hadoop/","section":"Tags","summary":"","title":"Hadoop","type":"tags"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/categories/hadoop/","section":"Categories","summary":"","title":"Hadoop","type":"categories"},{"content":"这篇文章并非原厂，是之前在网上找的，Hadoop MapReduce 的流程图，觉得很不错，就是网上的图太糊了，在这里重置一下。MR 作为大数据处理的基石，顺便梳理一下 MR 的流程。\nMapReduce 一共有 7 个角色参与，分为 4 个大阶段，7 个小阶段。分别是：\n任务启动阶段 由 Client 端发起请求； YarnRunner 接受请求并申请资源； ResourceManager 检索资源情况，分配资源路径给 YarnRunner； YarnRunner 进行分配，申请启动 MRAppMaster； ResourceManager 根据分片和 job 等信息，选择数据所在节点启动 MapTask（程序找数据），唤醒MRAppMaster； MRAppMaster 启动，持续监控和管理任务； MapTask 启动，开始干活； Map 阶段 数据读取，每个 task 读取自己节点上的数据； 数据处理 每个 task 对自己读取到的数据进行 split，分成更小的数据块； 对每个 split 的数据进行 map，提取 key、value、con； 对数据进行分区，有条件建议自定义分区，可以解决数据倾斜的问题，对之后的 reduce 也有极大的优化； 数据进入环形缓冲区，以起始点为赤道，到达溢出比后，刷新赤道； 溢出的数据刷入 sort 进行排序； 排序号的数据放入 spill，进行 merge 后有序写入 HDFS； Reduce 阶段 Reduce 启动 MRAppMaster 监控到 reduce 任务即将结束，开始申请启动 ReduceTask；RM 接受申请，根据分区结果，启动若干 ReduceTask。 ReduceTask启动，把每个 map 结果中的不同分区的数据，shuffle 数据到对应 ReduceTask 所在节点的缓存。 数据处理 在缓存中对每个 sotr 进行 merge（内存、缓存都有）； 将 merge 后的结果，重新进行 spill，排序后，落到 HDFS； 将所有小文件 merge 成一个大文件； Reduce 阶段 调用 Reduce 函数，对排序好的 file 进行汇总； 将最终结果写入到 HDFS 中； 任务结束阶段 MRAppMaster 监控到每个 Reduce 节点的执行情况； 向上汇报，并申请注销自己； RM 注销 MRAppMaster，并向上汇报； YarnRunner 返回任务完成信息； 客户端接受信息，任务结束。 整体流程图如下：\n\u0026hellip; 无奈，图片比较大，显示效果特别差，只能放链接了，后边想办法优化。\n链接：https://pan.baidu.com/s/1cF2CDo5NAzI7vOtQgvo_nw?pwd=r85y\n提取码：r85y\n","date":"2024-7-3","externalUrl":null,"permalink":"/posts/mr-image/","section":"Posts","summary":"","title":"MapReduce流程图（重制版）","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/","section":"Tags","summary":"","title":"大数据","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/categories/%E5%8D%9A%E5%AE%A2/","section":"Categories","summary":"","title":"博客","type":"categories"},{"content":" 选型 # 在 Hexo 和 Hugo 之间纠结了很久，开始尝试使用 Hexo 构建博客，搭建很快，主题很多，生成页面也比较漂亮，但是构建速度慢，外加没有找到自己喜欢的配色。再次尝试使用 Hugo 搭建，构建真快，主题也多，Blowfish 主题文档也全，使用体验真的没话说。\n前置条件 # 使用 Hugo 前，需要自己安装 Go 语言，Node.js，Git 等环境。安装很简单，本人是window系统，下载 amd64 位安装包，点点点，安装完成后验证就可以了。\nHugo 的安装需要注意，直接从 github 上下载 releases 版本的压缩包，解压缩后配置环境变量。Hugo 大部分主题都需要一些高级功能，所以直接下载 扩展版。\n配置好环境变量后，在 CMD 命令行查看是否安装成功。\nhugo version ## 出现如下提示，即为安装成功 hugo v0.128.0-e6d2712ee062321dc2fc49e963597dd5a6157660+extended windows/amd64 BuildDate=2024-06-25T16:15:48Z VendorInfo=gohugoio 开始搭建 # 其实 Hugo 中文文档 和 Blowfish 文档 已经很详细了，这里简要总结一下:\n使用 Hugo 构建项目 # Hugo new site your-site # your-site 请自行修改为自己的项目目录 cd your-site 注意，Hugo new site 要求文件夹必须为空，哪怕是有隐藏文件夹也会导致初始化失败。\n初始化后目录结构如下：\ngit init 各位可以先在 GitHub 上新建一个空白仓库，然后 git clone 下来。\nHugo new site your-site之后，将 .git 文件夹拷贝到 your-site 文件夹下，这样方便后续代码提交。\n安装主题 # 主题我这里使用的是 Blowfish 主题，优点是文档很全，而且文档支持中文，提供了多种主页布局方式和网站配色。我最喜欢的是‘Avocado’这个配色的深色模式，看起来很舒服。\n不建议使用 Blowfish-Tools 工具安装，除非你对 Hugo 框架很熟悉，知道每一个步骤都是在干什么，否则，不推荐使用它。\n推荐使用 使用 Git 子模块安装 主题。\ngit submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 下载好之后，目录 themes 中就会多出来一个 blowfish 的目录，里边就是主题的默认内容。\n设置主题的配置文件 # 在根目录中，删除 Hugo 自动生成的 hugo.toml 文件。从目录 themes/blowfish/config/_default 中复制 *.toml 文件，粘贴到 config/_default/ 目录中。Hugo 可以将这些配置统一放在一个 toml 文件中，也可以分多个 toml 文件，便于更好的管理。\n接着一定要设置 config/_default/hugo.toml 中的 theme = \u0026quot;blowfish\u0026quot;，这样才能使用对用的主题。\n关于 Blowfish 主题如何配置和使用，官网介绍已经很全了，详细内容请查看官网文档：Blowfish 文档 。\n接下来只说几个重要的点：\n自定义网站图标 # Blowfish 主题默认的网站图标是一条蓝色的小河豚，我们可以自定义自己喜欢的图标做自己的网站图标。\n网站图标资源的位置在 static/ 文件夹中，名称必须和下面的名称一样。如果使用了favicon.io，那么下载下来解压后的文件名和下面是完全一致的，直接拷贝到 static/ 中即可。\nstatic/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest 用 Hugo 创建文章 # 用 Hugo 创建一篇文章的命令是：\nhugo new xxx.md 用这个命令创建的 Markdown 文件会套用 archetypes 文件夹中的 front matter 模版，在空白处用 Markdown 写入内容。\n其中，draft = true 代表这篇文章是一个草稿，Hugo 生成页面不会显示草稿，要在主页显示此文章，可以设置 draft = false ，或者直接删掉这行。\n本地调试和预览 # 在发布到网站前，我们可以在本地预览网站的内容和效果，运行命令：\nhugo server 启动完成后，在浏览器输入 http//localhost:1313/ 可以实时预览生成的网站效果。\n使用上边的命令后，会发现文档上 draft = false 的文章不会显示，需要修改启动参数：\nhugo server -D 这样，草稿文章内容也会显示了。\n使用 GitHub Page 构建网站 # Hugo 提供非常详尽的 GitHub Pages 部署指引。这里对部署过程做简单梳理：\n在 ./.github/workflows/ 中放入 hugo.yml；\n将本地网站同步到 GitHub 同名仓库；\n在仓库设置 Settings -\u0026gt; Pages 中选择 Build and deployment 选择 GitHub Actions,将 Hugo 推送到 GitHub 上时,便会自动构建网页。\n完成以上步骤，你便可以通过 https://\u0026lt;your-github-id\u0026gt;.github.io 访问自己的个人博客。\n","date":"2024-6-28","externalUrl":null,"permalink":"/posts/build-blog/","section":"Posts","summary":"","title":"利用 GitHub Pages + Hugo 搭建个人博客","type":"posts"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%AB%99/","section":"Tags","summary":"","title":"网站","type":"tags"},{"content":" 一直在想，是不是做一个博客比较好，抽点时间，记录些东西也挺好。\n纠结了两天用哪个组件建立博客，看了 hexo、hugo 和 astro 三个组件，尝试了 hexo 和 hugo，最终还是决定用 hugo。\n其实在很早之前，我就想做一个自己的博客，记录下自己的学习和成长，哪怕不是技术相关的也好。人生的成长，技术只是一个方面，更多的还有思想、情商。技术力是很重要的一个方面，但也仅仅只是一个方面。\n小时候希望自己长大了当个科学家（貌似当时的教育，大家都是科学家）， 只知道学习，但是还学不好。考了个一般的本科，学了个一般的专业（土木🐶），找了个一般的工作。本想着在自己的专业做出点名堂，谁知道被社会狠狠的毒打。对于工地上的风气，我是深恶痛绝，再加上每周只能歇一天，我果断选择了转行，脱离了苦海。\n我也是挺佩服自己的，什么都不懂，就敢转行，想想年起的自己真的是很有胆量。于是听了同学减建议，背着书包，离开家乡，跑到帝都，租个破房，孤身一人，开始闯荡。一路从 JAVA 干到 大数据，甚至做过前端 VUE 项目，差点把自己干成全栈。熬了这么多年，目前只是一个不合格的组长（2024年）。\n庆幸自己转行的比较早，就目前这个形式，土木感觉都成夕阳行业了，IT 也不再是风口浪尖了，后续给人吹牛，还可以说自己是在浪尖待过那么一段时间的人呢，哈哈。\n趁自己还没老，抓紧做自己喜欢的事情。及时行乐，何尝不是一种洒脱。趁现在，从构建一个博客开始，加油，做自己想做的事情吧。\n","date":"2024-6-25","externalUrl":null,"permalink":"/posts/beginning/","section":"Posts","summary":"","title":"开篇","type":"posts"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/tags/%E9%9A%8F%E6%83%B3/","section":"Tags","summary":"","title":"随想","type":"tags"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/categories/%E6%9D%82%E9%A1%B9/","section":"Categories","summary":"","title":"杂项","type":"categories"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]