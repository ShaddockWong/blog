
[{"content":" 行为型模式 # 行为型模式（Behavioral Pattern）关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。\n行为型模式分为类行为型模式和对象行为型模式两种，其中类行为型模式使用继承关系在几个类之间分配行为，主要通过多态等方式来分配父类与子类的职责；而对象行为型模式则使用对象的关联关系来分配行为，主要通过对象关联等方式来分配两个或多个类的职责。根据合成复用原则，在系统中复用功能时要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。\n职责链模式概述 # **职责链模式：**避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接受请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。\nChain of Responsibility Pattern: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.\n职责链模式又称为责任链模式，它是一种对象行为型模式。\n职责链模式结构 # 职责链模式结构的核心在于引入了一个抽象处理者，其结构如下图所示：\n职责链模式结构图 包含以下两个角色：\nHandler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象（如图中的 successor）作为其下家的引用，通过该引用处理者可以连成一条链。 ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。 职责链模式实现 # 在职责链模式中很多对象由每一个对象对其下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不直到链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。\n职责链模式的核心在于抽象处理者的设计，抽象处理者的典型代码如下：\npublic abstract class Handler { // 维持对下家的引用 protected Handler successor; public void setSuccessor(Handler successor) { this.successor = successor; } public abstract void handleRequest(String request); } 抽象处理者类定义了对下家的引用对象，以便将请求转发给下家，该对象的访问符可设为 protected，在其子类中可以使用。\n具体处理者是抽象处理者的子类，它有两个作用：一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法 handleRequest()；二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。具体处理者类的典型代码如下：\npublic class ConcreteHandler extends Handler { public void handleRequest(String request) { if(请求满足条件){ // 处理请求 } else { this.successor.handleRequest(request); // 转发请求 } } } 在具体处理类中通过对请求进行判断可以做出相应的处理。\n需要注意的是，职责链模式并不负责创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。典型的客户端代码片段如下：\n... Handler handler1, handler2, handler3; handler1 = new ConcreteHandlerA(); handler2 = new ConcreteHandlerB(); handler3 = new ConcreteHandlerC(); // 创建职责链 handler1.setSuccessor(handler2); handler2.setSuccessor(handler3); // 发送请求，请求对象通常为自定义类型 handler1.handleRequest(\u0026#34;请求对象\u0026#34;); ... 职责链模式应用实例 # 实例说明 # 某企业的 SCM（Supply Chain Management，供应链管理）系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元以上的采购单则需要开董事会讨论决定，如下图所示：\n采购分级审批示意图 现使用职责链模式设计实现该系统。\n实例类图 # 采购单分级审批结构图 抽象类 Approver 充当抽象处理者（抽象传递者），Director、VicePresident、President 和 Congress 充当具体处理者（具体传递者），PurchaseRequest 充当请求类。\n实例代码 # PurchaseRequest：采购单类，充当请求类。\npublic class PurchaseRequest { private double amount; // 采购金额 private int number; // 采购单编号 private String purpose; // 采购目的 public PurchaseRequest(double amount, int number, String purpose) { this.amount = amount; this.number = number; this.purpose = purpose; } public double getAmount() { return amount; } public void setAmount(double amount) { this.amount = amount; } public int getNumber() { return number; } public void setNumber(int number) { this.number = number; } public String getPurpose() { return purpose; } public void setPurpose(String purpose) { this.purpose = purpose; } } Approver：审批者类，充当抽象处理者。\npublic abstract class Approver { protected Approver successor; // 定义后继对象 protected String name; // 审批者姓名 public Approver(String name) { this.name = name; } // 设置后继者 public void setSuccessor(Approver successor) { this.successor = successor; } // 抽象请求处理方法 public abstract void processRequest(PurchaseRequest request); } Director：主任类，充当具体处理者。\npublic class Director extends Approver { public Director(String name) { super(name); } // 具体请求处理方法 @Override public void processRequest(PurchaseRequest request) { if (request.getAmount() \u0026lt; 50000) { System.out.println(\u0026#34;主任\u0026#34; + this.name + \u0026#34;审批采购单：\u0026#34; + request.getNumber() + \u0026#34;，金额：\u0026#34; + request.getAmount() + \u0026#34;元，采购目的：\u0026#34; + request.getPurpose() + \u0026#34;.\u0026#34;); // 处理请求 } else { this.successor.processRequest(request); // 转发请求 } } } VicePresident：副董事长类，充当具体处理者。\npublic class VicePresident extends Approver { public VicePresident(String name) { super(name); } // 具体请求处理方法 @Override public void processRequest(PurchaseRequest request) { if (request.getAmount() \u0026lt; 100000) { System.out.println(\u0026#34;副董事长\u0026#34; + this.name + \u0026#34;审批采购单：\u0026#34; + request.getNumber() + \u0026#34;，金额：\u0026#34; + request.getAmount() + \u0026#34;元，采购目的：\u0026#34; + request.getPurpose() + \u0026#34;。\u0026#34;); // 处理请求 } else { this.successor.processRequest(request); // 转发请求 } } } President：董事长类，充当具体处理者。\npublic class President extends Approver{ public President(String name) { super(name); } // 具体请求处理方法 @Override public void processRequest(PurchaseRequest request) { if (request.getAmount() \u0026lt; 500000) { System.out.println(\u0026#34;董事长\u0026#34; + this.name + \u0026#34;审批采购单：\u0026#34; + request.getNumber() + \u0026#34;，金额：\u0026#34; + request.getAmount() + \u0026#34;元，采购目的：\u0026#34; + request.getPurpose() + \u0026#34;。\u0026#34;); // 处理请求 } else { this.successor.processRequest(request); // 转发请求 } } } Congress：董事会类，充当具体处理者。\npublic class Congress extends Approver { public Congress(String name) { super(name); } // 具体请求处理方法 @Override public void processRequest(PurchaseRequest request) { System.out.println(\u0026#34;召开董事会审批采购单：\u0026#34; + request.getNumber() + \u0026#34;，金额：\u0026#34; + request.getAmount() + \u0026#34;元，采购目的：\u0026#34; + request.getPurpose() + \u0026#34;。\u0026#34;); // 处理请求 } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Approver wjzhang, gyang, jguo, meeting; wjzhang = new Director(\u0026#34;张无忌\u0026#34;); gyang = new VicePresident(\u0026#34;杨过\u0026#34;); jguo = new President(\u0026#34;郭靖\u0026#34;); meeting = new Congress(\u0026#34;董事会\u0026#34;); // 创建职责链 wjzhang.setSuccessor(gyang); gyang.setSuccessor(jguo); jguo.setSuccessor(meeting); // 创建采购单 PurchaseRequest pr1 = new PurchaseRequest(45000, 10001, \u0026#34;购买倚天剑\u0026#34;); wjzhang.processRequest(pr1); PurchaseRequest pr2 = new PurchaseRequest(60000, 10002, \u0026#34;购买《葵花宝典》\u0026#34;); wjzhang.processRequest(pr2); PurchaseRequest pr3 = new PurchaseRequest(160000, 10003, \u0026#34;购买《金刚经》\u0026#34;); wjzhang.processRequest(pr3); PurchaseRequest pr4 = new PurchaseRequest(800000, 10003, \u0026#34;购买桃花岛\u0026#34;); wjzhang.processRequest(pr4); } } 结果及分析 # 主任张无忌审批采购单：10001，金额：45000.0元，采购目的：购买倚天剑。 副董事长杨过审批采购单：10002，金额：60000.0元，采购目的：购买《葵花宝典》。 董事长郭靖审批采购单：10003，金额：160000.0元，采购目的：购买《金刚经》。 召开董事会审批采购单：10003，金额：800000.0元，采购目的：购买桃花岛。 如果需要增加一个新的具体处理者，由于链的创建过程由客户端负责，因此增加新的具体处理者类对原有类库无任何影响，无须修改已有类的源代码，符合开闭原则。\n在客户端代码中，如果要将新的具体请求处理者应用在系统中，需要创建新的具体处理者对象，然后将该对象加入职责链中。\n例如：\nApprover new = new Manager(\u0026#34;黄蓉\u0026#34;); wjzhang.setSuccessor(rhuang); // 将黄蓉作为张无忌的下家 rhuang.setSuccessor(gyang); // 将杨过作为黄蓉的下家 纯与不纯的职责链模式 # 纯的职责链模式 # 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个，要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且纯的职责链模式中要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。上节的例子就是纯的职责链模式。\n不纯的职责链模式 # 在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。\nJava AWT 1.0 中的事件处理模型应用的是不纯的职责链模式。原理如下：由于窗口组件（如按钮、文本框等）一般位于容器组件中，因此当事件发生在某一个组件上时先通过组件对象的 handleEvent() 方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。早起 Java AWT 事件模型中的这种事件处理机制又叫事件浮升（Event Bubblling）机制。从 Java 1.1 以后，JDK 使用观察者模式代替职责链模式来处理事件。\n职责链模式优点 # 职责链模式使得一个对象无须直到是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，并且链中的对象不需要直到链的结构，由客户端负责链的创建，降低了系统的耦合度。 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象之间的相互连接。 再给对象分派职责时，职责链可以带来更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 在系统中增加一个新的具体请求处理者无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点看是符合开闭原则的。 职责链模式缺点 # 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 对于比较长的职责链，请求的处理可能涉及多个处理独享，系统性能将收到一定的影响，而且在进行代码调试时不太方便。 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。 职责链模式适用环境 # 有多个对象可以处理同一个请求，具体哪些对象处理请求待运行时再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 在不明确指定接收者的情况下向多个对象中的一个提交一个请求。 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 ","date":"2024-8-9","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater16/","section":"Posts","summary":"","title":"16-职责链模式","type":"posts"},{"content":"","date":"2024-8-9","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2024-8-9","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"2024-8-9","externalUrl":null,"permalink":"/categories/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Categories","summary":"","title":"Java设计模式","type":"categories"},{"content":"","date":"2024-8-9","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-8-9","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"弱小和无知不是生存的障碍，傲慢才是。\n三体\n","date":"2024-8-9","externalUrl":null,"permalink":"/","section":"你应该看不见我吧","summary":"","title":"你应该看不见我吧","type":"page"},{"content":"","date":"2024-8-9","externalUrl":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"Tags","summary":"","title":"设计模式","type":"tags"},{"content":" 代理模式概述 # 由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。\n代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。\n代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制原对象的访问。\nProxy Pattern: Provide a surrogate or placeholder for another object to control access to it.\n代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端和目标对象之间起到中介作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\n代理模式结构 # 代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层，代理模式的结构如图所示：\n代理模式结构图 包含以下3个角色：\nSubject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。 Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代主题对象；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。 RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。 代理模式实现 # 代理模式的结构图比较简单，但是在真实的使用和实现过程中要复杂很多，特别是代理类的设计和实现。\n抽象主题类声明了真实主题类和代理类的公共方法，它可以是接口、抽象类或具体类，客户端针对抽象主题类编程，一致性地对待真实主题和代理主题。典型的抽象主题类代码如下：\npublic abstract class Subject { public abstract void request(); } 真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：\npublic class RealSubject extends Subject { public void request(){ // 业务方法的具体实现代码 } } 代理类也是抽象主题类的字类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩充和约束。最简单的代理类实现代码如下：\npublic class Proxy extends Subject { private RealSubject realSubject = new RealSubject(); // 维持一个对真实主题对象的引用 public void preRequest() { ... } public void request() { preRequest(); realSubject.request(); // 调用真实主题对象的方法 postRequest(); } public void postRequest() { ... } } 在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，对其中常用的几种代理模式简要说明如下。\n远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大师（Ambassador）。 虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，例如将对象被调用的次数记录下来等。 代理模式应用实例 # 实例说明 # 某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本要求如下：\n在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统。 在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。 该软件公司的开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。\n试使用代理模式设计并实现该收费商务信息查询系统。\n实例类图 # 通过分析，可以采用一种间接访问的方式来实现该商务信息查询系统的设计，在客户端对象和信息查询对象之间增加一个代理对象，让代理对象实现身份验证和日志记录等功能，而无需直接对原有的商务信息查询对象进行修改，如下图：\n商务信息查询系统设计方案示意图 在上图中，客户端对象通过代理对象间接访问具有商务信息查询功能的真实对象，在代理对象中除了调用真实对象的商务信息查询功能外，还增加了身份验证和日志记录等功能。使用代理模式设计该商务信息查询系统，结构图如图所示：\n商务信息查询系统结构图 在图中，业务类 AccessValidator 用于验证用户身份，业务类 Logger 用于记录用户查询日志，Searcher 充当抽象主题角色，RealSearcher 充当真实主题角色，ProxySearcher 充当代理主题角色。\n实例代码 # AccessValidator：身份验证类（业务类），它提供 validate() 方法来实现身份验证。\npublic class AccessValidator { // 模拟实现登录验证 public boolean validate(String userId) { System.out.println(\u0026#34;在数据库中验证用户\u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;是否为合法用户？\u0026#34;); if (userId.equalsIgnoreCase(\u0026#34;杨过\u0026#34;)) { System.out.println(\u0026#34;\u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;登录成功！\u0026#34;); return true; } else { System.out.println(\u0026#34;\u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;登录失败！\u0026#34;); return false; } } } Logger：日志记录类（业务类），它提供 log() 方法来保存日志。\npublic class Logger { // 模拟实现日志记录 public void log(String userId) { System.out.println(\u0026#34;更新数据库，用户\u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;查询次数加 1！\u0026#34;); } } Searcher：抽象查询类，充当抽象主题角色，它声明了 doSearch() 方法。\npublic interface Searcher { public String doSearch(String userId, String keyword); } RealSearcher：具体查询类，充当真实主题角色，它实现查询功能，提供 doSearch() 方法来查询信息。\npublic class RealSearcher implements Searcher { // 模拟查询商务信息 @Override public String doSearch(String userId, String keyword) { System.out.println(\u0026#34;用户\u0026#39;\u0026#34; + userId + \u0026#34;\u0026#39;使用关键词\u0026#39;\u0026#34; + keyword + \u0026#34;\u0026#39;查询商务信息！\u0026#34;); return \u0026#34;返回具体内容\u0026#34;; } } ProxySearcher：代理查询类，充当代理主题角色，它是查询代理，维持了对 RealSearch 对象，AccessValidator 对象和 Logger 对象的引用。\npublic class ProxySearcher implements Searcher { private RealSearcher searcher = new RealSearcher(); // 维持一个对真实主题的引用 private AccessValidator validator; private Logger logger; @Override public String doSearch(String userId, String keyword) { // 如果身份验证成功，则执行查询 if (this.validator(userId)) { String result = searcher.doSearch(userId, keyword); // 调用真实主题对象的查询方法 this.log(userId); return result; } else { return null; } } // 创建访问验证对象并调用其 validate() 方法实现身份验证 private boolean validator(String userId) { validator = new AccessValidator(); return validator.validate(userId); } // 创建日志记录对象并调用其 log() 方法实现日志记录 private void log(String userId) { logger = new Logger(); logger.log(userId); } } 配置文件 config.xml，在配置文件中存储了代理主题类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.proxy.demo.ProxySearcher\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Searcher searcher; // 针对抽象编程，客户端无须分别真实主题类和代理类 searcher = (Searcher) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/proxy/demo/config.xml\u0026#34;); String result = searcher.doSearch(\u0026#34;杨过\u0026#34;, \u0026#34;玉女心经\u0026#34;); } } 结果及分析 # 输出结果如下：\n在数据库中验证用户\u0026#39;杨过\u0026#39;是否为合法用户？ \u0026#39;杨过\u0026#39;登录成功！ 用户\u0026#39;杨过\u0026#39;使用关键词\u0026#39;玉女心经\u0026#39;查询商务信息！ 更新数据库，用户\u0026#39;杨过\u0026#39;查询次数加 1！ 本实例是保护代理和智能引用代理的应用实例，在代理类 ProxySearcher 中实现对真实主题类的权限控制和引用计数，如果需要在访问真实主题时，增加新的访问控制机制和新功能，只需增加一个新的代理类，再修改配置文件，在客户端代码中使用新增代理类即可，源代码无须修改，符合开闭原则。\n远程代理 # 远程代理（Remote Proxy）是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不比考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程方法的调用。\n远程代理中，客户端不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。\n远程代理示意图 虚拟代理 # 虚拟代理（Virtual Proxy）也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后虚拟代理将用户的请求转发给真实对象。\n通常在一下两种情况下可以考虑使用虚拟代理：\n由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。 当一个对象的加载十分耗费系统资源的时候也非常适合使用虚拟代理。 虚拟代理是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。\nJava 动态代理 # 代理类所实现的接口和所代理的方法都是固定的，这种代理被称为静态代理（Static Proxy）。动态代理（Dynamic Proxy）可以让系统在运行时根据实际需要来创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法。动态代理是一种较为高级的代理模式，它在事务管理、AOP（Aspect-Oriented Programming，面向方向编程）等领域都发挥了重要的作用。\nJava 实现动态代理需要用到位于 java.lang.reflect 包中的一些类：\nProxy 类\nProxy 类提供了用于创建动态代理类和实例对象的方法，它是所创建的动态代理的父类，它最常用的方法如下。\n（1）public static Class \u0026lt;?\u0026gt; getProxyClass (ClassLoader loader, Class \u0026lt;?\u0026gt;... interfaces) ：该方法用于返回一个 Class 类的代理类，在参数中需要提供类加载器并需要指定代理的接口数组（与真实主题类的接口列表一致）。\npublic static Object newProxyInstance(ClassLoader loader, Class \u0026lt;?\u0026gt;[] interfaces, InvocationHandler h)：该方法用于返回一个动态创建的代理类的实例，方法中的第一个从那时 loader 表示代理类的类加载器，第二个参数 interfaces 表示代理类所实现的接口列表（与真实主题类的接口列表一致），第三个参数 h 表示所指派的调用处理程序类。\nInvocationHandler 接口\nInvocationHandler 接口是代理类处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者（InvocationHandler 接口的子类）。在该接口中声明了如下方法:\npublic Object invoke(Object proxy, Method method, Object[] args)\n该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke() 方法包含3个参数，其中第一个参数 proxy 表示代理类的实例，第二个参数 method 表示需要代理的方法，第三个参数 args 表示代理方法的参数数组。\n动态代理需要在运行时指定所代理这是主题类的接口，客户端在调用动态代理对象的方法时调用请求自动转发给 InvocationHandler 对象的 invoke() 方法，由 invoke() 方法来实现对请求的统一处理。\n下面通过一个简单实例来学习如何使用动态代理模式：\n实例说明 # 某软件公司要为公司 OA 系统数据访问层 DAO 增加方法调用日志，记录每一个方法被调用的时间和调用结果，现使用动态代理进行设计和实现。\n实例代码 # AbstractUserDAO：抽象用户 DAO 类，抽象主题角色。\npublic interface AbstractUserDAO { public Boolean findUserById(String userId); } AbstractDocumentDAO：抽象文档 DAO 类，抽象主题角色。\npublic interface AbstractDocumentDAO { public Boolean deleteDocumentById(String documentId); } UserDAO：用户 DAO 类，具体主题角色。\npublic class UserDAO implement AbstractUserDAO { public Boolean findUserById(String userId) { if(userId.equalsIgnoreCase(\u0026#34;张无忌\u0026#34;)) { System.out.println(\u0026#34;查询 ID 为\u0026#34; + userId + \u0026#34;的用户信息成功！\u0026#34;); return true; } else { System.out.println(\u0026#34;查询 ID 为\u0026#34; + userId + \u0026#34;的用户信息失败！\u0026#34;); return false; } } } DocumentDAO：文档 DAO 类，具体主题角色。\npublic class DocumentDAO implement AbstractDocumentDAO { public Boolean deleteDocumentById(String documentId) { if(documentId.equalsIgnoreCase(\u0026#34;D001\u0026#34;)) { System.out.println(\u0026#34;删除 ID 为\u0026#34; + documentId + \u0026#34;的文档信息成功！\u0026#34;); return true; } else { System.out.println(\u0026#34;删除 ID 为\u0026#34; + documentId + \u0026#34;的文档信息失败！\u0026#34;); return false; } } } DAOLogHandler：自定义请求处理程序类。\npublic class DAOLogHandler implements InvocationHandler { private Calendar calendar; private Object object; public DAOLogHandler() { } // 自定义有参构造函数，用于注入一个需要提供代理的真实主题对象 public DAOLogHandler(Object object) { this.object = object; } // 实现 invoke() 方法，调用在真实主题类中定义的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { beforeInvoke(); Object result = method.invoke(object, args);// 转发调用 afterInvoke(); return result; } // 记录方法调用时间 private void beforeInvoke() { calendar = new GregorianCalendar(); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); String time = hour + \u0026#34;:\u0026#34; + minute + \u0026#34;:\u0026#34; + second; System.out.println(\u0026#34;调用时间：\u0026#34; + time); } private void afterInvoke() { System.out.println(\u0026#34;方法调用结束！\u0026#34;); } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { InvocationHandler handler = null; AbstractUserDAO userDAO = new UserDAO(); handler = new DAOLogHandler(userDAO); AbstractUserDAO proxy = null; // 动态创建代理对象，用于代理一个 AbstractUserDAO 类型的真实主题对象 proxy = (AbstractUserDAO) Proxy.newProxyInstance( AbstractUserDAO.class.getClassLoader(), new Class[]{AbstractUserDAO.class}, handler ); proxy.findUserById(\u0026#34;张无忌\u0026#34;); // 调用代理对象的业务方法 System.out.println(\u0026#34;--------------------------------\u0026#34;); AbstractDocumentDAO docDAO = new DocumentDAO(); handler = new DAOLogHandler(docDAO); AbstractDocumentDAO proxy_new = null; // 动态创建代理对象，用于代理一个 AbstractDocumentDAO 类型的真实主题对象 proxy_new = (AbstractDocumentDAO) Proxy.newProxyInstance( AbstractDocumentDAO.class.getClassLoader(), new Class[]{AbstractDocumentDAO.class}, handler ); proxy_new.deleteDocumentById(\u0026#34;D002\u0026#34;); // 调用代理对象的业务方法 } } 运行结果分析 # 调用时间：10:45:28 查询 ID 为张无忌的用户信息成功！ 方法调用结束！ -------------------------------- 调用时间：10:45:28 删除 ID 为D002的文档信息失败！ 方法调用结束！ 通过使用动态代理可以实现对多个真实主题类的统一代理和集中控制。\nJDK 中提供的动态代理只能代理一个或多个接口，如果需要动态代理具体类或抽象类，可以使用 CGLib（Code Generation Library）等工具。CGLib 是一个功能较为强大、性能和质量也比较好的代码生成包，在许多 AOP 框架中得到了广泛应用。\n代理模式优点 # 代理模式的共同优点如下：\n能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可编程性。 不同类型的代理模式具有独特的优点：\n远程代理为位于两个不同地址空间的对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率。 虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。 缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。 代理模式缺点 # 由于在客户端和真实主题之间增加了对象代理，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。 代理模式适用环境 # 当客户端对象需要访问远程主机中的对象时可以使用远程代理。 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。 当需要控制对一个对象的访问为不同用户提供不同级别的访问权限时可以使用保护代理。 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。 ","date":"2024-8-6","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater15/","section":"Posts","summary":"","title":"15-代理模式","type":"posts"},{"content":" 享元模式概述 # 如果一个软件系在运行时创建的相同或相似对象数量太多，将导致运行代价过高，带来系统资源浪费、性能下降等问题。享元模式通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中存储这些共享实例对象的地方称为享元池（Flyweight Pool）。可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，当需要时再从享元池取出。\n字符享元对象示意图 享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态（Intrinsic State）和外部状态（Extrinsic State）。下面将对享元的内部状态和外部状态进行简单的介绍。\n内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后需要使用的时候再传入到享元对象内部。外部状态之间是相互独立的。 正因为区分了内部状态和外部状态，可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，当需要的时候就将对象从享元池中取出，实现对象的复用。通常向取出的对象注入不同的外部状态可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。\n享元模式：运用共享技术有效地支持大量细粒度对象的复用。\nFlyweight Pattern: Use sharing to support large numbers of fine-grained objects efficiently.\n享元模式要求能够被共享的对象必须是细粒度对象，它又称为轻量级模式，享元模式是一种对象结构型模式。\n享元模式结构 # 享元模式的结构较为复杂，通常结合工厂模式一起使用，在它的结构图中包含了一个享元工厂类，其结构如图所示：\n享元模式结构图 享元模式包含以下 4 个角色：\nFlyweight（抽象享元类）：抽象享元类通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以想外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 ConcreteFlyweight（具体享元类）：具体享元类实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在），返回新创建的实例并将其存储在享元池中。 享元模式实现 # 享元类 Flyweight 的设计是享元模式的要点之一，为了提高系统的可扩展性，通常会定义一个抽象享元类作为所有具体享元类的公共父类，典型的抽象享元类代码如下：\npublic abstract class Flyweight { public abstract void operation(String extrinsicState); } 在具体享元类 ConcreteFlyweight 中要将内部状态和外部状态分开处理，通常将内部状态作为具体享元类的成员变量，而外部状态通过注入的方式添加到具体享元类中。典型的具体享元类代码如下：\npublic class ConcreteFlyweight extends Flyweight { // 内部状态 intrinsicState 作为成员变量，同一个享元对象的内部状态是一致的 private String intrinsicState; public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } // 外部状态 extrinsicState 在使用时由外部设置，不保存在享元对象中，即使是同一个对象， // 在每一次调用时可以传入不同的外部状态 public void operations(String extrinsicState) { // 实现业务方法 } } 除了可以共享的具体享元类以外，在使用享元模式时有时候还需要处理那些不需要共享的抽象享元类 Flyweight 的子类，这些子类被定义为非共享具体享元类 UnsharedConcreteFlyweight，其典型代码如下：\npublic class UnsharedConcreteFlyweight extends Flyweight { public void operation(String extrinsicState) { // 实现业务方法 } } 在享元模式中引入了享元工厂类 FlyweightFactory，享元工厂类的作用是提供一个用于存储享元对象的享元池，当用户需要对象时首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。典型的享元工厂类的代码如下：\npublic class FlyweightFactory { // 定义一个 HashMap 用于存储享元对象，实现享元池 private HashMap flyweight = new HashMap(); public Flyweight getFlyweight(String key) { // 如果对象存在，则直接从享元池获取 if(flyweight.containsKey(key)) { return (Flyweight)flyweight.get(key); } // 如果对象不存在，现创建一个新的对象添加到享元池中，然后返回 else { Flyweight fw = new ConcreteFlyweight(); } } } 享元模式应用实例 # 案例说明 # 某软件公司要开发一个围棋软件。该公司的开发人员通过对周围围棋软件进行分析发现，在围棋棋盘中包含大量的黑子和白子，它们的形状、大小一模一样，只是出现的位置不同而已。如果将每一个棋子作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需的内存空间较大，那么如何降低运行代价、提高系统性能是需要解决的一个问题。\n为了解决该问题，现使用享元模式来设计该围棋软件的棋子对象。\n围棋棋子结构图 IgoChessman 充当抽象享元类，BlackIgoChessman 和 WhiteIgoChessman 充当具体享元类，IgoChessmanFactory 充当享元工厂类。\n实例代码 # IgoChessman：围棋棋子类，充当抽象享元类。\npublic abstract class IgoChessman { public abstract String getColor(); public void display() { System.out.println(\u0026#34;棋子颜色：\u0026#34; + this.getColor()); } } BlackIgoChessman：黑色棋子类，充当具体享元类。\npublic class BlackIgoChessman extends IgoChessman{ @Override public String getColor() { return \u0026#34;黑色\u0026#34;; } } WhiteIgoChessman：白色棋子类，充当具体享元类。\npublic class WhiteIgoChessman extends IgoChessman { @Override public String getColor() { return \u0026#34;白色\u0026#34;; } } IgoChessmanFactory：围棋棋子工厂类，充当享元工厂类，使用单例模式对其进行设计。\npublic class IgoChessmanFactory { private static IgoChessmanFactory instance = new IgoChessmanFactory(); private static Hashtable ht; // 使用 Hashtable 来存储享元对象，充当享元池 private IgoChessmanFactory() { ht = new Hashtable(); IgoChessman black, white; black = new BlackIgoChessman(); ht.put(\u0026#34;b\u0026#34;, black); white = new WhiteIgoChessman(); ht.put(\u0026#34;w\u0026#34;, white); } // 返回享元工厂类的唯一实例 public static IgoChessmanFactory getInstance() { return instance; } // 通过 key 获取存储在 Hashtable 中的享元对象 public static IgoChessman getIgoChessman(String color) { return (IgoChessman) ht.get(color); } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { IgoChessman black1, black2, black3, white1, white2; IgoChessmanFactory factory; // 获取享元工厂对象 factory = IgoChessmanFactory.getInstance(); // 通过享元工厂获取 3 颗黑子 black1 = factory.getIgoChessman(\u0026#34;b\u0026#34;); black2 = factory.getIgoChessman(\u0026#34;b\u0026#34;); black3 = factory.getIgoChessman(\u0026#34;b\u0026#34;); System.out.println(\u0026#34;判断两颗黑子是否相同：\u0026#34; + (black1 == black2)); // 通过享元工厂获取 2 颗白子 white1 = factory.getIgoChessman(\u0026#34;w\u0026#34;); white2 = factory.getIgoChessman(\u0026#34;w\u0026#34;); System.out.println(\u0026#34;判断两颗白子是否相同：\u0026#34; + (white1 == white2)); // 显示棋子 black1.display(); black2.display(); black3.display(); white1.display(); white2.display(); } } 结果及分析 # 输出结果如下：\n判断两颗黑子是否相同：true 判断两颗白子是否相同：true 棋子颜色：黑色 棋子颜色：黑色 棋子颜色：黑色 棋子颜色：白色 棋子颜色：白色 虽然在客户端代码中获取了 3 个黑子对象和两个白子对象，但是它们的内存地址相同，也就是说它们实际上是同一个对象。\n有外部状态的享元模式 # 虽然黑色棋子和白色棋子可以共享，但是它们将显示在棋盘的不同位置，如何让相同的黑子或者白子能够多次重复显示且位于一个棋盘的不同地方？解决方案之一就是将棋子的位置定义为棋子的一个外部状态，在需要时再进行设置。\n引入外部状态之后的围棋棋子结构图 可以在上面的结构中新增加一个 Coordinates（坐标类），在抽象享元类 IgoChessman 中的 display() 方法也对应增加一个 Coordinates 类型的参数，用于在显示棋子时指定其坐标。\nCoordinates 类的代码如下：\npublic class Coordinates { private int x; private int y; public Coordinates(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } } 修改之后的 IgoChessman 类代码如下：\npublic abstract class IgoChessman { public abstract String getColor(); public void display(Coordinates coord) { System.out.println(\u0026#34;棋子颜色：\u0026#34; + this.getColor() + \u0026#34;，棋子位置：\u0026#34; + coord.getX() + \u0026#34;,\u0026#34; + coord.getY()); } } 将客户端测试代码修改如下：\npublic class Client { public static void main(String[] args) { IgoChessman black1, black2, black3, white1, white2; IgoChessmanFactory factory; // 获取享元工厂对象 factory = IgoChessmanFactory.getInstance(); // 通过享元工厂获取 3 颗黑子 black1 = factory.getIgoChessman(\u0026#34;b\u0026#34;); black2 = factory.getIgoChessman(\u0026#34;b\u0026#34;); black3 = factory.getIgoChessman(\u0026#34;b\u0026#34;); System.out.println(\u0026#34;判断两颗黑子是否相同：\u0026#34; + (black1 == black2)); // 通过享元工厂获取 2 颗白子 white1 = factory.getIgoChessman(\u0026#34;w\u0026#34;); white2 = factory.getIgoChessman(\u0026#34;w\u0026#34;); System.out.println(\u0026#34;判断两颗白子是否相同：\u0026#34; + (white1 == white2)); // 显示棋子,同时设置棋子的坐标位置 black1.display(new Coordinates(1, 2)); black2.display(new Coordinates(3, 4)); black3.display(new Coordinates(1, 3)); white1.display(new Coordinates(2, 5)); white2.display(new Coordinates(2, 4)); } } 运行输出结果如下：\n判断两颗黑子是否相同：true 判断两颗白子是否相同：true 棋子颜色：黑色，棋子位置：1,2 棋子颜色：黑色，棋子位置：3,4 棋子颜色：黑色，棋子位置：1,3 棋子颜色：白色，棋子位置：2,5 棋子颜色：白色，棋子位置：2,4 在每次调用 display() 方法时都设置了不同的外部状态 \u0026ndash; 坐标值，因此相同的棋子对象虽然有相同的颜色，但是它们的坐标值不同，将显示在棋盘的不同位置。\n单纯享元模式和复合享元模式 # 单纯享元模式 # 在单纯享元模式汇总所有的具体享元类都是可以共享的，不存在非共享具体享元类。单纯享元模式结构如图所示：\n单纯享元模式结构图 复合享元模式 # 将一些单纯享元对象使用组合模式加以组合还可以形成符合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者可以共享。复合享元模式的结构图如图所示：\n复合享元模式结构图 通过使用复合享元模式可以让符合享元类 CompositeConcreteFlyweight 中所包含的每个单纯享元类 ConcreteFlyweight 都具有相同的外部状态，而这些单纯享元的内部状态往往可以不同。\n享元模式和 String 类 # JDK 类库中的 String 类使用了享元模式，在修改享元对象时先将原有对象复制一份，然后在新对象上实时修改操作的机制称为 “Copy On Write”。\n享元模式优点 # 享元模式可以减少内存中对象的数量，使得相同或者相似对象在内存中只保存了一份，从而可以节约系统资源，提高系统性能。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使享元对象可以在不同的环境中被共存。 享元模式缺点 # 享元模式使系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 为了使对象可以共存，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使运行时间变长。 享元模式适用环境 # 一个系统有大量相同或相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此应当在需要多次重复使用享元对象时才使用享元模式。 ","date":"2024-7-31","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater14/","section":"Posts","summary":"","title":"14-享元模式","type":"posts"},{"content":" 外观模式概述 # 在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要教化的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂。此时，就需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需要和该类交互。\n外观模式通过引入一个新的外观类（Facade）来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。\n外观模式示意图 在外观模式汇总，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户与子系统的内部复杂性分隔开，是的客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。\n外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\nFacade Pattern：Provided a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\n外观模式又称为门面模式，它是一种对象结构型模式。，外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。\n外观模式结构 # 外观模式没有一个一般化的类图描述，通常用下图描述外观模式的结构图：\n外观模式结构图 外观模式包含以下两个角色：\nFacade（外观角色）：在客户端可以调用它的方法，在外观角色汇总可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。 SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。 外观模式实现 # 外观模式的主要目的是在于降低系统的复杂程度。引入外观模式后，增加新的子系统或者移除子系统都很方便，客户类无需进行修改（或者极少的修改），只需要在外观类汇总增加或移除对子系统的引用即可。从这一点来看，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改。\n外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，典型代码如下：\npublic class SubSystemA { public void methodA() { // 业务实现代码 } } public class SubSystemB { public void methodB() { // 业务实现代码 } } public class SubSystemC { public void methodC() { // 业务实现代码 } } 在引入外观类之后，与子系统业务类之间的交互统一由外观类来完成，在外观类中通常存在如下代码：\npublic class Facade { private SubSystemA obj1 = new SubSystemA(); private SubSystemB obj2 = new SubSystemB(); private SubSystemC obj3 = new SubSystemC(); public void method() { obj1.methodA(); obj2.methodB(); obj3.methodC(); } } 由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无需与子系统对象直接交互。在引入外观类后，客户端代码变得非常简单：\npublic class Client { public static void main(String args[]) { Facade facade = new Facade(); facade.method(); } } 外观模式应用实例 # 实例说明 # 某软件公司要开发一个可应用多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包含 3 个部分，分别是读取源文件、加密、保存加密之后的文件，其中读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这 3 个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这 3 个操作的业务代码封装在 3 个不同的类中。现使用外观模式设计该文件加密模块。\n实例类图 # 文件加密模块结构图 EncryptFacade 充当外观类，FileReader、CipherMachine 和 FileWriter 充当子系统类。\n实例代码 # FileReader：文件读取类，充当子系统类。\npublic class FileReader { public String read(String fileNameSrc) { System.out.println(\u0026#34;读取文件，获取明文：\u0026#34;); StringBuffer sb = new StringBuffer(); try { FileInputStream inFS = new FileInputStream(fileNameSrc); int data; while ((data = inFS.read()) != -1) { sb = sb.append((char) data); } inFS.close(); System.out.println(sb.toString()); } catch (FileNotFoundException e) { System.out.println(\u0026#34;文件不存在！\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;文件操作错位！\u0026#34;); } return sb.toString(); } } CipherMachine：数据加密类，充当子系统。\npublic class CipherMachine { public String encrypt(String plainText) { String es = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; plainText.length(); i++) { String c = String.valueOf(plainText.charAt(i) % 7); es += c; } System.out.println(es); return es; } } FileWriter：文件保存类，充当子系统数。\npublic class FileWriter { public void write(String encryptStr, String fileNameDes) { System.out.println(\u0026#34;保存密文，写入文件。\u0026#34;); try { FileOutputStream outFS = new FileOutputStream(fileNameDes); outFS.write(encryptStr.getBytes()); outFS.close(); } catch (FileNotFoundException e) { System.out.println(\u0026#34;文件不存在！\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;文件操作错误！\u0026#34;); } } } EncryptFacade：加密外观类，充当外观类。\npublic class EncryptFacade { // 维持对子系统对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() { reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); } // 调用子系统对象的业务方法 public void fileEncrypt(String fileNameSrc, String fileNameDes) { String plainStr = reader.read(fileNameSrc); String encryptStr = cipher.encrypt(plainStr); writer.write(encryptStr, fileNameDes); } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { EncryptFacade ef = new EncryptFacade(); ef.fileEncrypt(\u0026#34;design-pattern/src/main/java/com/wangyq/facade/demo/src.txt\u0026#34;, \u0026#34;design-pattern/src/main/java/com/wangyq/facade/demo/des.txt\u0026#34;); } } 输出如下：\n读取文件,获取明文：Hello world! 数据加密,将明文转换为密文：233364062325 保存密文,写入文件。 抽象外观类 # 在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，者将违背开闭原则。因此可以通过引入抽象外观类对系统进行改进。引入抽象外观类后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。\n如果在本章的应用实例“文件加密模块”中需要更换一个加密类，不再使用原有的基于求模运算的加密类 CipherMachine，而改为基于移位运算的新加密类 NewCipherMachine，其代码如下：\npublic class NewCipherMachine { public String encrypt(String plainText) { System.out.print(\u0026#34;数据加密，将明文转换为密文：\u0026#34;); String es = \u0026#34;\u0026#34;; int key = 10; // 设置密钥，移位数为 10 for (int i = 0; i \u0026lt; plainText.length(); i++) { char c = plainText.charAt(i); // 小写字母移位 if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) { c += key % 26; if (c \u0026gt; \u0026#39;z\u0026#39;) { c -= 26; } if (c \u0026lt; \u0026#39;a\u0026#39;) { c += 26; } } // 大写字母移位 if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) { c += key % 26; if (c \u0026gt; \u0026#39;Z\u0026#39;) { c -= 26; } if (c \u0026lt; \u0026#39;A\u0026#39;) { c += 26; } } es += c; } System.out.println(es); return es; } } 引入抽象外观类之后的文件加密模块结构如图所示：\n引入抽象外观类之后的文件加密模块结构图 抽象外观类 AbstractEncryptFacade 的代码如下：\npublic abstract class AbstractEncryptFacade { public abstract void fileEncrypt(String fileNameSrc, String fileNameDes); } 新增具体加密外观类 NewEncryptFacade 的代码如下：\npublic class NewEncryptFacade extends AbstractEncryptFacade { private FileReader reader; private NewCipherMachine cipher; private FileWriter writer; public NewEncryptFacade() { reader = new FileReader(); cipher = new NewCipherMachine(); writer = new FileWriter(); } @Override public void fileEncrypt(String fileNameSrc, String fileNameDes) { String plainStr = reader.read(fileNameSrc); String encryptStr = cipher.encrypt(plainStr); writer.write(encryptStr, fileNameDes); } } 配置文件 config.xml 中存储量具体外观类的类名，代码如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.facade.demo.NewEncryptFacade\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; 客户端测试代码修改如下：\npublic class Client { public static void main(String[] args) { // 针对抽象外观类编程 AbstractEncryptFacade ef; // 读取配置文件，反射生成对象 ef = (AbstractEncryptFacade) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/facade/demo/config.xml\u0026#34;); ef.fileEncrypt(\u0026#34;design-pattern/src/main/java/com/wangyq/facade/demo/src.txt\u0026#34;, \u0026#34;design-pattern/src/main/java/com/wangyq/facade/demo/des.txt\u0026#34;); } } 输出结果如下：\n读取文件，获取明文：Hello world! 数据加密，将明文转换为密文：Rovvy gybvn! 保存密文，写入文件。 原有外观类 EncryptFacade 也需要作为抽象外观类 AbstractEncryptFacade 的子类，在更换具体外观类时只需修改配置文件，无需修改源代码，符合开闭原则。\n外观模式优点 # 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使子系统使用起来更加容易。 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 外观模式缺点 # 不能很好地限制客户端直接使用子系统，如果对客户端访问子系统做太多的限制则减少了可变性和灵活性。 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 外观模式适用环境 # 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。 在层次化结构中可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 ","date":"2024-7-29","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater13/","section":"Posts","summary":"","title":"13-外观模式","type":"posts"},{"content":" 装饰模式概述 # 装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。在软件设计中，装饰模式是一种用于替代继承的技术，它通过一种无需定义字类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。\n装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。\nDecorator Pattern：Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.\n装饰模式是一种对象结构型模式，它以对客户透明的方式动态地给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下让对象的功能得以扩展。\n装饰模式结构 # 装饰模式结构如下图所示：\n装饰模式结构图 装饰模式包含以下 4 个角色：\nComponent（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）：它是抽象构件类的字类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）：它也是抽象构建类的字类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，达到装饰的目的。 ConcreteDecorator（具体装饰类）：它是抽象装饰类的字类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰中定义的方法，并可以增加新的方法用于扩充对象的行为。 装饰模式实现 # 在装饰模式中，抽象构件类一般设计为抽象类或者接口，在其中声明了抽象业务方法，当然也可以在抽象构件类中实现一些所有具体构件类都共有的业务方法。抽象构件类的典型代码如下：\npublic abstract class Component { public abstract void operation(); } 具体构建类作为抽象构件类的字类实现了在抽象构件中声明的业务方法，通常在具体构建类中只提供基本功能的实现，一些复杂的功能需要通过装饰类进行扩展。其典型代码如下：\npublic class ConcreteComponent extends Component { public void operation() { // 基本功能实现 } } 装饰模式的核心在于抽象装饰类的设计，其典型代码如下：\npublic class Decorator extends Component { private Component component; // 维持一个对抽象构件对象的引用 // 注入一个抽象构件类型的对象 public Decorator(Component component) { this.component = component; } public void operation() { component.operation(); // 调用原有业务方法 } } 在抽象装饰类 Decorator 中定义了一个 Component 类型的对象 component，维持一个对抽象构件对象的引用，并可以通过构造方法或 Setter 方法将一个 Component 类型的对象注入进来，同时由于 Decorator 类实现了抽象构件 Component 接口，因此需要实现在其中声明的业务方法 operation()。值得注意的是，在 Decorator 中并未真正实现 operation() 方法，只是调用原有 component 对象的 operation() 方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。\n在 Decorator 的子类（即具体装饰类）中将继承 operation() 方法并根据需要进行扩展，典型的具体装饰类代码如下：\npublic class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } public void operation() { super.operation(); // 调用原有业务方法 addedBehavior(); // 调用新增业务方法 } // 新增业务方法 public void addedBehavior() { ... } } 在具体装饰类中可以调用到抽象装饰类的 operation() 方法，同时可以定义新的业务方法，例如 addedBehavior()。如果该方法不希望客户端单独调用，可以将其可见性设为私有（private）。\n由于在抽象装饰类 Decorator 中注入的是 Component 类型的对象，因此可以将一个具体构件对象注入其中，再通过具体装饰类进行装饰；此外，还可以将一个已经装饰过的 Decorator 子类的对象再注入其中进行多次装饰，从而实现对原有功能的多次扩展。\n装饰模式应用实例 # 实例说明 # 某软件公司基于面向对象技术开发了一套图形界面构件库 VisualComponent，该构件库提供了大量的基本构件，如窗体、文本框、列表框等，由于在使用该构件库时用户经常要求定制一些特殊的显示效果，如带滚动条的窗体、带黑色边框的文本框、既带滚动条又带黑色边框的列表框等，因此经常需要对该构件库进行扩展以增强其功能。现使用装饰模式来设计该图形界面构件库。\n实例类图 # 图形界面构件库结构图 Component 充当抽象构建类，其子类 Window、TextBox、ListBox 充当具体构件类，Component 类的另一个字类 ComponentDecorator 充当抽象装饰类，ComponentDecorator 的子类 ScrollBarDecorator 和 BlackBorderDecorator 充当具体装饰类。\n实例代码 # Component：抽象界面构件类，充当了抽象构件类。为了突出与模式相关的核心代码，在本实例中对控件代码进行了大量的简化。\npublic abstract class Component { public abstract void display(); } Window：窗体类，充当具体构件类。\npublic class Window extends Component{ @Override public void display() { System.out.println(\u0026#34;显示窗体！\u0026#34;); } } TextBox：文本框类，充当具体构件类。\npublic class TextBox extends Component{ @Override public void display() { System.out.println(\u0026#34;显示文本框！\u0026#34;); } } ListBox：列表框类，充当具体构件类。\npublic class ListBox extends Component{ @Override public void display() { System.out.println(\u0026#34;显示列表框！\u0026#34;); } } ComponentDecorator：构建装饰类，充当抽象装饰类。\npublic class ComponentDecorator extends Component { private Component component; // 维持对抽象构件类型对象的引用 // 注入抽象构件类型的对象 public ComponentDecorator(Component component) { this.component = component; } @Override public void display() { component.display(); } } ScrollBarDecorator：滚动条装饰类，充当具体装饰类。\npublic class ScrollBarDecorator extends ComponentDecorator{ public ScrollBarDecorator(Component component) { super(component); } @Override public void display() { this.setScrollBar(); super.display(); } public void setScrollBar() { System.out.println(\u0026#34;为构建增加滚动条！\u0026#34;); } } BlackBorderDecorator：黑色边框装饰类，充当具体装饰类。\npublic class BlackBorderDecorator extends ComponentDecorator { public BlackBorderDecorator(Component component) { super(component); } @Override public void display() { this.setBlackBorder(); super.display(); } public void setBlackBorder() { System.out.println(\u0026#34;为构件增加黑色边框\u0026#34;); } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Component component, componentSB; // 使用抽象构件定义对象 component = new Window(); // 创建具体构件对象 componentSB = new ScrollBarDecorator(component); // 创建装饰后的构件对象 componentSB.display(); } } 结果及分析 # 输出结果如下\n为构建增加滚动条！ 显示窗体！ 如果希望的到一个既有滚动条，又有黑色边框的窗体，不需要对原有类库进行任何修改，只需要将客户端代码修改如下：\npublic class Client { public static void main(String[] args) { Component component, componentSB, componentBB; // 使用抽象构件定义对象 component = new Window(); // 创建具体构件对象 componentSB = new ScrollBarDecorator(component); // 创建装饰后的构件对象 componentBB = new BlackBorderDecorator(componentSB); // 将装饰了一次的对象注入另一个装饰类中，进行第二次装饰 componentBB.display(); } } 再次编译并运行程序，输出结果如下：\n为构件增加黑色边框 为构建增加滚动条！ 显示窗体！ 如果需要在原有系统中增加一个新的具体构件类或者新的具体装饰类，无需修改现有类库代码，只需将它们分别作为抽象构件类或者抽象装饰类的子类即可。\n透明装饰模式与半透明装饰模式 # 在标准的装饰模式中，新增行为需要在原有业务方法中调用，无论是具体构件对象还是装饰过的构件对象，对于客户端而言都是透明的，这种装饰模式被称为透明（Transparent）装饰模式。但是在某些情况下，有些新增行为可能需要单独被调用，此时客户端不能再一致性地处理之前的对象和装饰之后的对象，这种装饰模式被称为半透明（Semi-transparent）装饰模式。\n透明装饰模式 # 在透明装饰模式中要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。也就是应该使用以下代码了：\nComponent component_o, component_d; // 使用抽象构件类型定义对象 component_o = new ConcreteComponent(); component_d = new ConcreteDecorator(component_o); component_d.operation(); 使用抽象构件类型 Component 定义全部具体构件对象和具体装饰对象，客户端可以一致地使用这些对象，因此符合透明装饰模式的要求。\n透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无需关心它们的区别，此外还可以对一个已装饰过的对象进行多次装饰，得到更加复杂、功能更加强大的对象。\n半透明装饰模式 # 透明装饰模式的设计难度较大，而且有时需要单独调用新增的业务方法。为了能够调用到新增方法，不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型仍然可以使用抽象构件类型来定义，这种装饰模式即半透明装饰模式。对客户端而言，具体构件类型无需关系，是透明的，但是具体装饰类型必须指定，这是不透明的。客户端代码片段如下：\n... Component component_o;\t// 使用抽象构件类型定义 component_o = new ConcreteComponent(); component_o.operation(); ConcreteDecorator component_d;\t// 使用具体构件类型定义 component_d = new ConcreteDecorator(component_o); component_d.operation();\t// 单独调用新增业务方法 ... 半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但其最大的缺点在于不能实现同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。实现半透明装饰模式时只需要在具体装饰类中增加一个独立的 addedBehavior() 方法来封装对应的业务处理，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用 addedBehavior() 方法。\n装饰模式优点 # 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合可以创造出很多不同行为的组合，得到功能更加强大的对象。 具体构建类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构建类和具体装饰类，原有类库代码无须改变，符合开闭原则。 装饰模式缺点 # 在使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是他们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能。 装饰模式提供了一种比继承更加灵活、机动的解决方案，但同时也意味着比继承更加易于出错，排错也更加困难，对于多次装饰的对象，在调试时寻找错误可能需要逐级排查，较为繁琐。 装饰模式适用环境 # 在不影响其他对象的情况下以动态、透明的方式给单个对象添加职责。 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（例如在 Java 语言中使用 final 关键字修饰的类） ","date":"2024-7-25","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater12/","section":"Posts","summary":"","title":"12-装饰模式","type":"posts"},{"content":" 组合模式概述 # 树形目录结构示意图 对于所有与目录结构相类似的树形结构，当容器对象（例如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，例如子文件夹和文件）并调用执行，牵一而动百，其中是用了递归调用的机制对整个结构进行处理。\n组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无需对他们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。\n组合模式：组合多个对象形成树形结构以表示具体部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。\nComposite Pattern: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\n组合模式又称“部分-整体”（Part-Whole）模式，属于对象结构型模式，它将对象组织到树形结构中，可以用来描述整体与部分的关系。\n组合模式结构 # 组合模式结构图 组合模式包含以下 3 个角色：\nComponent（抽象构件）：它可以是结构或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有字类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件。 Leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。 Composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子节点，其子节点可以是叶子结点，也可以是容器结点，它提供了一个结合用于存储子结点，实现了在抽象构件中定义的行为，包括哪些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。 组合模式实现 # 组合模式的关键在于定义了一个抽象构建类，它既可以代表叶子，又可以代表容器，客户端针对该抽象构件类进行编程，无需知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象和抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，又可以包含容器，以此实现递归组合，形成一个树形结构。\n如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，造成代码维护困难，可扩展性差等问题，组合模式的使用将在一定程度常解决这些问题。\n对于组合模式中的抽象构件角色，其典型代码如下：\npublic abstract class Component { public abstract void add(Component c);\t// 增加成员 public abstract void remove(Componet c);\t// 删除成员 public abstract Component getChild(int i);\t// 获取成员 public abstract void operation();\t// 业务方法 } 一般将抽象构件类设计为接口或抽象类，将所有字类共有方法的声明和实现放在抽象构件类中。对于客户端而言，将针对抽象构件编程，而无需关心其具体子类是容器构件还是叶子构件。\n如果继承抽象构件的是叶子构件，其典型代码如下：\npublic class Leaf extends Component { public void add(Componet c) { // 异常处理或错误提示 } public void remove(Component c) { // 异常处理或错误提示 } public Component getChild(int i) { // 异常处理或错误提示 return null; } public void operation() { // 叶子构件具体业务方法的实现 } } 作为抽象构件类的字类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理和错误提示。显然，这会给叶子构件的实现带来麻烦。\n如果继承抽象构件的是容器构件，其典型代码如下：\nimport java.util.*; public class Composite extends Component { private ArrayList\u0026lt;Component\u0026gt; list = new ArrayList\u0026lt;Component\u0026gt;(); public void add(Component c) { list.add(c); } public void remove(Component c) { list.remove(c); } public Component getChild(int i) { return (Component)list.get(i); } public void operation() { // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法 for(Object obj:list) { ((Component)obj).operation(); } } } 在组合模式结构中，由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时，需要使用递归算法，即在容器构件的 operation() 方法中递归调用其成员构件的 operation() 方法。\n组合模式应用实例 # 实例说明 # 某软件公司要开发一个杀毒（Antivirus）软件，该软件既可以对某个文件夹（Folder）杀毒，也可以对某个指定的文件（File）杀毒。该杀毒软件还可以根据各类文件的特点为不同类型的文件提供不同的杀毒方式，例如图像文件（ImageFile）和文本文件（TextFile）的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。\n实例类图 # 杀毒软件框架设计结构图 AbstractFile 充当抽象构件类，Folder 充当容器构件类，ImageFile、TextFile 和 VideoFile 充当叶子构件类。\n实例代码 # AbstractFile：抽象文件类 ，充当抽象构件类。\npublic abstract class AbstractFile { public abstract void add(AbstractFile file); public abstract void remove(AbstractFile file); public abstract AbstractFile getChild(int i); public abstract void killVirus(); } ImageFile：图像文件类，充当叶子构件类。\npublic class ImageFile extends AbstractFile { private String name; public ImageFile(String name) { this.name = name; } @Override public void add(AbstractFile file) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); } @Override public void remove(AbstractFile file) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); } @Override public AbstractFile getChild(int i) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); return null; } @Override public void killVirus() { // 模拟杀毒 System.out.println(\u0026#34;---- 对图像文件\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;进行杀毒\u0026#34;); } } TextFile：文本文件类，充当叶子构件类。\npublic class TextFile extends AbstractFile { private String name; public TextFile(String name) { this.name = name; } @Override public void add(AbstractFile file) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); } @Override public void remove(AbstractFile file) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); } @Override public AbstractFile getChild(int i) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); return null; } @Override public void killVirus() { // 模拟杀毒 System.out.println(\u0026#34;---- 对文本文件\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;进行杀毒\u0026#34;); } } VideoFile：视频文件类，充当叶子构件类。\npublic class VideoFile extends AbstractFile { private String name; public VideoFile(String name) { this.name = name; } @Override public void add(AbstractFile file) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); } @Override public void remove(AbstractFile file) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); } @Override public AbstractFile getChild(int i) { System.out.println(\u0026#34;对不起，不支持该方法！\u0026#34;); return null; } @Override public void killVirus() { // 模拟杀毒 System.out.println(\u0026#34;---- 对视频文件\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;进行杀毒\u0026#34;); } } Folder：文件夹类，充当容器构建类。\npublic class Folder extends AbstractFile { // 定义集合 fileList，用于存储 AbstractFile 类型的成员 private ArrayList\u0026lt;AbstractFile\u0026gt; filesList = new ArrayList\u0026lt;AbstractFile\u0026gt;(); private String name; public Folder(String name) { this.name = name; } @Override public void add(AbstractFile file) { filesList.add(file); } @Override public void remove(AbstractFile file) { filesList.remove(file); } @Override public AbstractFile getChild(int i) { return filesList.get(i); } @Override public void killVirus() { System.out.println(\u0026#34;**** 对文件夹\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;进行杀毒\u0026#34;); // 模拟杀毒 // 递归调用成员构件的 killVirus() 方法 for (Object obj : filesList) { ((AbstractFile) obj).killVirus(); } } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { // 针对抽象构件编程 AbstractFile file1, file2, file3, file4, file5, folder1, folder2, folder3, folder4; folder1 = new Folder(\u0026#34;Sunny 的资料\u0026#34;); folder2 = new Folder(\u0026#34;图像资料\u0026#34;); folder3 = new Folder(\u0026#34;文本资料\u0026#34;); folder4 = new Folder(\u0026#34;视频资料\u0026#34;); file1 = new ImageFile(\u0026#34;小龙女.jpg\u0026#34;); file2 = new ImageFile(\u0026#34;张无忌.jpg\u0026#34;); file3 = new TextFile(\u0026#34;九阴真经.txt\u0026#34;); file4 = new TextFile(\u0026#34;葵花宝典.doc\u0026#34;); file5 = new VideoFile(\u0026#34;笑傲江湖.rmvb\u0026#34;); folder2.add(file1); folder2.add(file2); folder3.add(file3); folder3.add(file4); folder4.add(file5); folder1.add(folder2); folder1.add(folder3); folder1.add(folder4); // 从 \u0026#34;Sunny的资料\u0026#34; 结点开始进行杀毒操作 folder1.killVirus(); } } 结果及分析 # 输出结果如下：\n**** 对文件夹\u0026#39;Sunny 的资料\u0026#39;进行杀毒 **** 对文件夹\u0026#39;图像资料\u0026#39;进行杀毒 ---- 对图像文件\u0026#39;小龙女.jpg\u0026#39;进行杀毒 ---- 对图像文件\u0026#39;张无忌.jpg\u0026#39;进行杀毒 **** 对文件夹\u0026#39;文本资料\u0026#39;进行杀毒 ---- 对文本文件\u0026#39;九阴真经.txt\u0026#39;进行杀毒 ---- 对文本文件\u0026#39;葵花宝典.doc\u0026#39;进行杀毒 **** 对文件夹\u0026#39;视频资料\u0026#39;进行杀毒 ---- 对视频文件\u0026#39;笑傲江湖.rmvb\u0026#39;进行杀毒 在本实例中，抽象构件类声明了所有方法，包括用于管理和访问子构件的方法，例如 add() 方法和 remove() 方法等，因此在 ImageFile 等叶子构件类中实现这些方法时必须进行相应的异常处理或错误提示。在容器构件类 Folder 的 killVirus() 方法中将递归调用其成员对象的 killVirus() 方法，从而实现对整个树形结构的遍历。\n如果需要更换操作结点，例如只对文件夹“文本文件”进行杀毒，客户端代码只需修改一行即可，将代码：\nfolder1.killVirus(); 改为\nfolder3.killVirus(); 在具体实现时可以创建图形化界面让用户来选择所需操作的根结点，无需修改源代码，符合开闭原则，客户端无需关心结点的层次结构，可以对所选结点进行统一处理，提高系统的灵活性。\n透明组合模式与安全组合模式 # 透明组合模式 # 在透明组合模式中，抽象构件 Component 中声明了所有用于管理成员对象的方法，包括 add()、remove() 以及 getChild() 等方法，如下图所示，这样做的好处是确保所有的构建类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的。\n透明组合模式结构图 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一层的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错。\n安全组合模式 # 在安全组合模式中，抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 Composite 类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法，如下图所示。\n安全组合模式结构图 安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高。\n组合模式优点 # 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加了新的容器构件和叶子构件都很方便，无需对现有类库进行任何修改，符合开闭原则。 为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合可以形成复杂的树形结构，但对树形结构的控制却非常简单。 组合模式缺点 # 在增加新构件时很难对容器中的构件类型进行限制。有时候希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，在使用组合模式时不能依赖类型系统来施加这些约束，因为他们都来自与相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。\n组合模式适用环境 # 在具有整体和部分的层次结构中希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 在一个使用面向对象语言开发的系统中需要处理一个树形结构。 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 Java SE 中的 AWT 好 Swing 报的设计就基于组合模式，在这些界面包中为用户提供了大量的容器构件（如 Container）和成员构件（如 Checkbox、Button 和 TextComponent 等），其结构如图所示：\nAWT 组合模式结构示意图 ","date":"2024-7-22","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater11/","section":"Posts","summary":"","title":"11-组合模式","type":"posts"},{"content":" 桥接模式概述 # 毛笔和蜡笔是两种很常见的文具，假如需要大、中、小 3 种型号的画笔，能够绘制 12 中不同的颜色，如果使用蜡笔，需要准备 3 × 12 = 36 支；使用毛笔，只需要提供 3 中型号的毛笔，外加 12 种颜色的调色板，设计的对象个数仅为 3 + 12 = 15，却能实现 36支蜡笔同样的功能。\n通过分析不难发现：在蜡笔中，颜色和型号两个不同的变化维度耦合在一起，无论是对颜色进行扩展还是对型号进行扩展，势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响。在软件开发中有一种设计模式可以用来处理与画笔类似的具有多变化维度的情况，它就是桥接模式。\n桥接模式中将两个独立变化的维度，设计为两个独立的继承等级结构，而不是将二者耦合在一起形成多层继承结构。在抽象层建立起一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。\n桥接模式：将抽象部分与它的实现部分解耦，使的两者都能够独立变化。\nBridge Pattern: Decouple an abstraction from its implemenmtation so that the two can vary independently.\n桥接模式是一种对象结构模式，又称为柄体（Handle and Body）模式或接口（Interface）模式。\n桥接模式结构 # 桥接模式结构图 桥接模式包含以下 4 个角色：\nAbstraction（抽象类）：用于定义抽象类的接口，通常是抽象类而不是结构，其中定义了一个 Implementor（实现类接口）类型的对象并可以维护该对象，它与 Implementor 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。 RefinedAbstraction（扩充抽象类）：它扩充由 Abstraction 定义的接口，通常情况下它不再是抽象类而是具体类，实现了在 Abstraction 中声明的抽象业务方法，在 RefinedAbstraction 中可以调用在 Implementor 中定义的业务方法。 Implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同。一般而言，Implementor 接口仅提供基本操作，而 Abstraction 定义的接口可能会做更多更复杂的操作。Implementor 接口对这些基本操作进行了声明，而具体实现交给其字类。通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用到 Implementor 中定义的方法，使用关联关系来替代继承关系。 ConcreteImplementor（具体实现类）：它具体实现了 Implementor 接口，在不同的 ConcreteImplementor 中提供了基本操作的不同实现，在程序运行时 ConcreteImplementor 对象将替换其父类对象，提供给抽象类具体的业务操作方法。 桥接模式实现 # 桥接模式是一个非常使用的设计模式，在桥接模式中体现了很多面向对象的设计原则的思想，包括单一指责原则、开闭原则、合成服用原则、里氏代换原则、依赖倒转原则等。\n在使用桥接模式时首先应识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。在同常情况下，将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。\n在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象管理关系。对于“实现部分”维度，典型的实现类接口代码如下：\npublic interface Implementor { public void operationImpl(); } 在实现 Implementor 接口的子类 ConcreteImplementor 中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：\npublic class ConcreteImplementor implements Implementor { public void operationImpl() { // 具体业务方法的实现 } } 对于另一“抽象部分”维度而言，其典型的抽象代码如下：\npublic abstract class Abstraction { protected Implementor impl; // 定义实现类接口对象 public void setImpl(Implementor impl) { this.impl = impl; } public abstract void operation(); // 声明抽象业务方法 } 在抽象类 Abstraction 中定义了一个实现类接口类型的成员变量impl，再通过 Setter 方法或者构造方法以注入的方式给该对象赋值，一般将该对象的可见性定义为 protected，一边在其子类中访问 Implementor 的方法，其子类一般称为扩充抽象类或细化抽象类（RefinedAbstraction），典型的 RefinedAbstraction 类代码如下：\npublic class RefinedAbstraction extends Abstraction { public void operation() { // 业务代码 impl.operationImpl(); // 调用实现类的方法 // 业务代码 } } 对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的字类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。\n桥接模式应用实例 # 实例说明 # 某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示 BMP、JPG、GIF、PNG 等多种格式的文件，并且能够在 Windows、Linux、UNIX 等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵（Matrix），然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。系统需具有较好的扩展性，以便在将来支持新的文件格式和操作系统。试使用桥接模式设计该跨平台图像浏览系统。\n实例类图 # 跨平台图像浏览系统结构图 实例代码 # Matrix：像素矩阵类，它是一个辅助类，各种格式的图像文件最终都被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵。\npublic class Matrix { // 代码省略 } ImageImp：抽象操作系统实现类，充当实现类接口。\npublic interface ImageImp { public void doPaint(Matrix m); // 显示像素矩阵 m } WindowsImp：Windows 操作系统实现类，充当具体实现类。\npublic class WindowsImp implements ImageImp{ @Override public void doPaint(Matrix m) { // 调用 Windows 系统的绘制函数绘制像素矩阵 System.out.println(\u0026#34;在 Windows 操作系统中显示图像：\u0026#34;); } } LinuxImp：Linux 操作系统实现类，充当具体实现类。\npublic class LinuxImp implements ImageImp { @Override public void doPaint(Matrix m) { // 调用 Linux 系统的绘制函数绘制像素矩阵 System.out.println(\u0026#34;在 Linux 操作系统中显示图像：\u0026#34;); } } UnixImp：UNIX 操作系统实现类，充当具体实现类。\npublic class UnixImp implements ImageImp{ @Override public void doPaint(Matrix m) { // 调用 UNIX 系统的绘制函数绘制像素矩阵 System.out.println(\u0026#34;在 UNIX 操作系统中显示图像：\u0026#34;); } } Image：抽象图像类，充当抽象类。\npublic abstract class Image { protected ImageImp imp; // 注入实现类接口对象 public void setImageImp(ImageImp imp) { this.imp = imp; } public abstract void parseFile(String fileName); } JPGImage：JPG 格式图像类，充当扩充抽象类。\npublic class JPGImage extends Image{ @Override public void parseFile(String fileName) { // 模拟解析 JPG 文件并获得一个像素矩阵对象 m Matrix m = new Matrix(); imp.doPaint(m); System.out.println(fileName + \u0026#34;，格式为 JPG。\u0026#34;); } } PNGImage：PNG 格式图像类，充当扩充抽象类。\npublic class PNGImage extends Image{ @Override public void parseFile(String fileName) { // 模拟解析 PNG 文件并获得一个像素矩阵对象 m Matrix m = new Matrix(); imp.doPaint(m); System.out.println(fileName + \u0026#34;，格式为 PNG。\u0026#34;); } } BMPImage：BMP 格式图像类，充当扩充抽象类。\npublic class BMPImage extends Image{ @Override public void parseFile(String fileName) { // 模拟解析 BMP 文件并获得一个像素矩阵对象 m Matrix m = new Matrix(); imp.doPaint(m); System.out.println(fileName + \u0026#34;，格式为 BMP。\u0026#34;); } } GIFImage：GIF 格式图像类，充当扩充抽象类。\npublic class GIFImage extends Image{ @Override public void parseFile(String fileName) { // 模拟解析 GIF 文件并获得一个像素矩阵对象 m Matrix m = new Matrix(); imp.doPaint(m); System.out.println(fileName + \u0026#34;，格式为 GIF。\u0026#34;); } } 配置文件 config.xml，在配置文件中存储了具体扩充抽象类和具体实现类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;!-- RefinedAbstraction --\u0026gt; \u0026lt;className\u0026gt;com.wangyq.bridge.demo.JPGImage\u0026lt;/className\u0026gt; \u0026lt;!-- ConcreteImplementor --\u0026gt; \u0026lt;className\u0026gt;com.wangyq.bridge.demo.WindowsImp\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\npublic class XMLUtil { /** * 该方法用于从 XML 配置文件中提取具体类的类名，并返回一个实例对象 * * @param args args * @return {@link Object } */ public static Object getBean(String args) { try { // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/bridge/demo/config.xml\u0026#34;)); NodeList nl = null; Node classNode = null; String cName = null; nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); // 获取第一个包含类名的节点，即扩充抽象类 if (args.equals(\u0026#34;image\u0026#34;)) { classNode = nl.item(0).getFirstChild(); } // 获取第二个包含类名的节点，即具体实现类 else if (args.equals(\u0026#34;os\u0026#34;)) { classNode = nl.item(1).getFirstChild(); } cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Image image; ImageImp imp; image = (Image) XMLUtil.getBean(\u0026#34;image\u0026#34;); imp = (ImageImp) XMLUtil.getBean(\u0026#34;os\u0026#34;); image.setImageImp(imp); image.parseFile(\u0026#34;小龙女\u0026#34;); } } 结果及分析 # 运行结果如下：\n在 Windows 操作系统中显示图像： 小龙女，格式为 JPG。 在实际使用使可以通过分析图像文件格式扩展名来确定具体的文件格式，在程序运行时获取操作系统类型，无需使用配置文件。当增加新的图像文件格式或者操作系统时原有代码无需任何修改，只需要增加一个对应的扩充抽象类或具体实现类即可，完全符合开闭原则。\n桥接模式与适配器模式的联用 # 适配器模式可以解决两个已有接口不兼容的问题，在这种情况下被适配的类往往是一个黑盒子。适配器模式通常用于现有系统和第三方产品功能的集成，采用增加适配器的方式将第三方类集成到系统中。桥接模式则不同，用户可以通过接口继承或类继承的方式对系统进行扩展。\n桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使他们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时可以采用适配器模式。\n下面通过一个实例来说明适配器模式和桥接模式的联合使用：\n在某系统的报表处理模块中需要将报表显示和数据输出分开，系统可以有多种报表显示方式也可以有多种数据输出方式，例如可以将数据输出为文本文件，也可以输出为 Excel 文件，如果需要输出为 Excel 文件，则需要调用与 Excel 相关的 API，而这个 API 是现有系统所不具备的，该 API 由厂商提供，因此可以同时使用适配器模式和桥接模式来设计该模块。\n桥接模式与适配器模式联用示意图 桥接模式优点 # 分离抽象接口及实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了单一指责原则，复用性较差，并且类的个数非常多，桥接模式是比多层继承方案更好的解决方案，它极大地减少了子类的个数。 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度都不需要修改原有系统，符合开闭原则。 桥接模式缺点 # 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。 桥接模式要求正确地识别系统中的两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。 桥接模式适用环境 # 如果一个系统需要在抽象层和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使他们在抽象层建立一个关联关系。 抽象部分和实现部分可以用继承的方式独立扩展而互不影响，在程序运行时可以动态地将一个抽象化子类的对象和一个实现化字类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态解耦。 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。 对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 ","date":"2024-7-19","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater10/","section":"Posts","summary":"","title":"10-桥接模式","type":"posts"},{"content":" 适配器模式概述 # 我们国家生活用电是 220V，而笔记本、手机等电子设备的工作电压没有这么高，为了使这些电子设备可以使用 220V 的生活用电，就需要使用电源适配器。\n在软件开发中有时也存在类似这种不兼容的情况，也可以像引入一个电源适配器那样，引入一个称为适配器的角色来协调这种存在不兼容的结构，这种设计方案即为适配器模式。\n在适配器模式中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象称为适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。\n适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。\nAdapter Pattern: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn\u0026rsquo;t otherwise because of incompatible interfaces.\n适配器模式的别名为包装类（Wrapper）模式，它既可以作为类结构型模式，也可以作为对象结构型模式。\n适配器模式结构 # 适配器模式包括类适配器和对象适配器。\n类适配器模式的结构如下 图1 所示：\n图1 类适配器模式结构图 对象适配器模式的结构图如下 图2 所示：\n图2 对象适配器模式结构图 适配器模式包含以下 3 个角色。\nTarget（目标抽象类）：目标抽象类定义客户所需的接口，可以使一个抽象类或接口，也可以是具体类。在类适配器中，由于 Java 语言不支持多重继承，它只能是接口。 Adapter（适配器类）：它可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配。适配器类是适配器模式的核心，在类适配器中，它通过实现 Target 接口并继承 Adaptee 类来使二者产生联系，在对象适配器中，它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。 适配器模式实现 # 类适配器 # 在类适配器中适配者类 Adaptee 没有 request() 方法，而客户端期待这个方法，蛋仔适配者类中实现了 specificRequest() 方法，该方法提供的实现正是客户端所需要的。为了使客户端能够使用适配者类，提供了一个中间类，即适配器类 Adapter，适配器类实现了抽象目标接口 Target，并继承了适配者类，在适配器类 request() 方法中调用所继承的适配者类的 specificRequest() 方法，达到了适配的目的。因为适配器类和适配者类是继承关系，所以这种适配器模式称为类适配器模式。典型代码如下：\npublic class Adapter extends Adaptee implements Target { public void request() { super.specificRequest(); } } 对象适配器 # 在对象适配器中客户端需要调用 request() 方法，而适配者类 Adaptee() 没有该方法，但是它提供的 specificRequest() 方法确实客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类 Adapter，即适配器类。这个包装类包装类一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的 request() 方法中调用适配者的 specificRequest() 方法。因为适配器类与适配者类是关联关系（也称委派关系），所以这种适配器模式称为对象适配器模式。典型代码如下：\npublic class Adapter extends Target { private Adaptee adaptee; // 维持一个对适配者对象的引用 public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { adaptee.specificRequest(); // 转发调用 } } 适配器模式更多的是强调对代码的组织，而不是功能的实现。在实际开发中，对象适配器的使用频率更高。\n适配器模式应用实例 # 实例说明 # 某公司要开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁和声音提示的程序，为了重用先前的代码并且使汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。\n实例类图 # 汽车控制软件结构图 实例代码 # CarController：汽车控制类，充当目标抽象类。\npublic abstract class CarController { public void move() { System.out.println(\u0026#34;玩具汽车移动！\u0026#34;); } public abstract void phonate(); // 发出声音 public abstract void twinkle(); // 灯光闪烁 } PoliceSound：警笛类，充当适配者。\npublic class PoliceSound { public void alarmSound() { System.out.println(\u0026#34;发出警笛声！\u0026#34;); } } PoliceLamp：警灯类，充当适配者。\npublic class PoliceLamp { public void alarmLamp() { System.out.println(\u0026#34;呈现警灯闪烁！\u0026#34;); } } PoliceCarAdapter：警车适配器，充当适配器。\npublic class PoliceCarAdapter extends CarController { private PoliceSound sound; // 定义i适配者 PoliceSound 对象 private PoliceLamp lamp; // 定义适配者 PoliceLamp 对象 public PoliceCarAdapter() { sound = new PoliceSound(); lamp = new PoliceLamp(); } // 发出警笛声音 @Override public void phonate() { sound.alarmSound(); // 调用适配者类 PoliceSound 的方法 } // 呈现警灯闪烁 @Override public void twinkle() { lamp.alarmLamp(); // 调用适配者类 PoliceLamp 的方法 } } 配置文件 config.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.adapter.demo.PoliceCarAdapter\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; Client：客户端测试类\npublic class Client { public static void main(String[] args) { CarController car; car = (CarController) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/adapter/demo/config.xml\u0026#34;); car.move(); car.phonate(); car.twinkle(); } } 结果及分析 # 运行程序，输出结果如下：\n玩具汽车移动！ 发出警笛声音！ 呈现警灯闪烁！ 本实例中使用了对象适配器模式，同时引入了配置文件，如果需要使用其他声音类或者灯光类，可以增加一个新的适配器类，使用新的适配器来适配新的声音或者灯光类，原有代码无需修改，符合开闭原则。\n在本实例中目标抽象类是一个抽象类，而不是接口，并且实力中的适配器类 PoliceCarAdapter 同时适配了两个适配者，由于 Java 语言不支持多重类继承，因此本实例只能通过对象适配器来实现，而不能使用类适配器。在实际软件开发中对象适配器比类适配器更加灵活，使用频率更高。\n缺省适配器模式 # 缺省适配其模式是适配器模式的一种变体，其应用也比较广泛。\n缺省适配器模式（Default Adapter Pattern）：当不需要实现一个接口提供的所有方法时，可现设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适合于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。\n缺省适配器模式结构如下图所示：\n缺省适配器模式结构图 包含以下 3 个角色：\nServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。 AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在 ServiceInterface 接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。 ConcreteServiceClass（具体业务类）：它是缺省适配器类的字类，在没有引入适配器之前它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无需使用的方法不得不提供空实现。在有了缺省适配器之后可以直接继承该适配器类，根据需要有选择地覆盖在适配器类中定义的方法。 缺省适配器类的典型代码片段如下：\npublic abstract class AbstractServiceClass implements ServiceInterface { public void serviceMethod1() { } // 空方法 public void serviceMethod2() { } // 空方法 public void serviceMethod3() { } // 空方法 } 双向适配器 # 在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中方法，那么该适配器就是一个双向适配器，其结构如下图所示：\n双向适配器结构示意图 双向适配器的实现较为复杂，其典型代码如下：\npublic class Adapter implements Target, Adaptee { // 同时维持对抽象目标类和适配者的引用 private Target target; private Adaptee adaptee; public Adapter(Target target) { this.target = target; } public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { adaptee.specificRequest(); } public void specificRequest() { target.request() } } 适配器模式优点 # 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好，通过配置文件可以很方便地更换适配器，也无需修改原有代码，完全符合开闭原则。 具体来说，对于类适配器还有以下优点：\n由于适配器是适配者类的字类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器模式还有一下优点：\n一个对象适配器可以把多个不同的适配者适配到同一个目标； 可以适配一个适配者的字类，由于适配器和适配者时间是管理关系，根据里氏代换原则，适配者的字类也可通过该适配器进行适配。 适配器模式缺点 # 对于不支持多重继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。 适配者类不能为最终类。 在 Java、C# 等语言中，类适配器模式中的目标类只能为接口，不能为类，其使用具有一定的局限性。 对象适配器与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。 适配器模式适用环境 # 系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类（包括一些可能在将来引进的类）一起工作。 ","date":"2024-7-18","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater09/","section":"Posts","summary":"","title":"09-适配器模式","type":"posts"},{"content":" 单例模式概述 # 对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个计时工具或 ID（序号）生成器。\n单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\nSingleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.\n单例模式是一种对象创建型模式。有 3 个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n单例模式结构 # 单例模式是结构最简单的设计模式，它只包含一个类，即单例类。结构图如下图所示：\n单例模式结构图 单例模式只包含一个单例角色，就是 Singleton。\n对于 Singleton，在单例类的内部创建它的唯一实例，并通过静态方法 getInstance() 让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为 private；在单例类内部定义了一个 Singleton 类型的静态对象作为供外部共享访问的唯一实例。\n单例模式实现 # 单例模式包含的角色只有一个，也就是单例类 Singleton。单例类拥有一个私有构造函数，确保用户无法通过 new 关键字直接实例化它。除此之外，在单例类中还包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。\n单例模式的实现代码如下：\npublic class Singleton { private static Singleton instance = null; // 静态私有成员变量 // 私有构造方法 private Singleton() { } // 静态公有工厂方法，返回唯一实例 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 为了测试单例类所创建对象的唯一性，可以编写一下客户端测试代码：\npublic class Client { public static void main(String[] args) { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); // 判断两个对象是否相同 if(s1 == s2) { System.out.println(\u0026#34;两个对象实例相同\u0026#34;)； } else { System.out.println(\u0026#34;两个对象实例不同\u0026#34;)； } } } 输出结果为：\n两个对象是实例相同 这说明两次调用 getInstance() 时所获取的对象是同一实例对象，且无法在外部对 Singleton 进行实例化，因此确保系统中只有唯一的一个 Singleton 对象。\n在单例模式的实现过程中需要注意以下 3 点：\n单例类构造函数的可见性为 private。 提供一个类型为自身的静态私有成员变量。 提供一个供油的静态工厂方法。 单例模式应用实例 # 实例说明 # 某软件公司承接了一个服务器负载均衡（Load Balance）软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短相应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。\n实例类图 # 通过分析，本实例的结构图如下所示：\n服务器负载均衡器结构图 实例代码 # LoadBalancer：负载均衡类，充当单例角色。在真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，此处只列出部分与模式相关的核心代码。\npublic class LoadBalancer { // 私有静态成员变量，存储唯一实例 private static LoadBalancer instance = null; // 服务器集合 private List\u0026lt;String\u0026gt; serverList = null; // 私有构造函数 private LoadBalancer() { serverList = new ArrayList\u0026lt;\u0026gt;(); } // 公有静态成员方法，返回唯一实例 public static LoadBalancer getLoadBalancer() { if (instance == null) { instance = new LoadBalancer(); } return instance; } // 增加服务器 public void addServer(String server) { serverList.add(server); } // 删除服务器 public void removeServer(String server) { serverList.remove(server); } // 使用 Random 类随机获取服务器 public String getServer() { Random random = new Random(); int i = random.nextInt(serverList.size()); return serverList.get(i); } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { // 创建 4 个 LoadBalancer 对象 LoadBalancer balancer1, balancer2, balancer3, balancer4; balancer1 = LoadBalancer.getLoadBalancer(); balancer2 = LoadBalancer.getLoadBalancer(); balancer3 = LoadBalancer.getLoadBalancer(); balancer4 = LoadBalancer.getLoadBalancer(); // 判断服务器负载均衡器是否相同 if (balancer1 == balancer2 \u0026amp;\u0026amp; balancer2 == balancer3 \u0026amp;\u0026amp; balancer3 == balancer4) { System.out.println(\u0026#34;服务器负载均衡器具有唯一性！\u0026#34;); } // 增加服务器 balancer1.addServer(\u0026#34;Server 1\u0026#34;); balancer1.addServer(\u0026#34;Server 2\u0026#34;); balancer1.addServer(\u0026#34;Server 3\u0026#34;); balancer1.addServer(\u0026#34;Server 4\u0026#34;); // 模拟客户端请求的分发，如果输出结果为同一个 server，可以将 i 适当放大 // 例如，改为 \u0026#34;i \u0026lt; 100\u0026#34; for (int i = 0; i \u0026lt; 10; i++) { String server = balancer1.getServer(); System.out.println(\u0026#34;分发请求至服务器：\u0026#34; + server); } } } 运行结果及分析 # 服务器负载均衡器具有唯一性！ 分发请求至服务器：Server 1 分发请求至服务器：Server 2 分发请求至服务器：Server 1 分发请求至服务器：Server 2 分发请求至服务器：Server 1 分发请求至服务器：Server 3 分发请求至服务器：Server 2 分发请求至服务器：Server 1 分发请求至服务器：Server 3 分发请求至服务器：Server 2 虽然创建了 4 个 LoadBalancer 对象，但是它们实际上是同一个对象，因此通过使用单例模式可以确保 LoadBalancer 对象的唯一性。\n饿汉式单例和懒汉式单例 # 饿汉式单例 # 饿汉式单例（Eager Singleton）是实现起来最简单的单例类，其结构图如下图所示：\n饿汉式单例结构图 从图中可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载时单例对象就已创建，代码如下：\npublic class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() {} public static EagerSingleton getInstance() { return instance; } } 当类被加载时，静态变量 instance 会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。\n懒汉式单例类与双重检查锁定 # 与饿汉式单例类相同的是，懒汉式单例类（Lazy Singleton）的构造函数也是私有的。与懒汉式单例不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。其结构图如下：\n懒汉式单例结构图 懒汉式单例在第一次调用 getInstance() 方法时实例化，在了加载时并不自行实例化，这种技术称为延迟加载（懒加载 Lazy Load）技术，即需要的时候再加载实例。为了避免多个线程同时调用 getInstance() 方法，可以使用关键字 synchronized，代码如下：\npublic class LazySingleton { private static LazySingleton instance = null; private LazySingleton() { } // 使用 synchronized 关键字对方法加锁，确保任意时刻只有一个线程可执行该方法 synchronized public static LazySingleton getInstance() { if(instance == null) { instance = new LazySingleton(); } return instance; } } 上述代码虽然解决了线程安全问题，但是每次调用 getInstance() 时都需要进行线程锁定判断，在多线程高并发访问环境中将会导致系统性能大大降低，因此需要继续进行改写，getInstance() 方法可以进行如下改写。\n... public static LazySingleton getInstance() { if(instance == null) { synchronize(LazySingleton.class) { instance = new LazySingleton(); } } return instance; } ... 这样实现单例类后，还是会存在单例对象不唯一的情况，原因为：假如在某一瞬间线程 A 和 线程 B 都在调用 getInstance() 方法，此时 instance 对象为 null 值，均能通过 instance == null 的判断。由于实现了 synchronized 加锁机制，线程 A 进入 synchronized 锁定的代码中执行实例创建代码，线程 B 处于排队等待状态，必须等待线程 A 执行完毕后才可以进入 synchronized 锁定的代码。但当 A 执行完毕时线程 B 并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背了单例模式的设计思想，所以要进一步改进，在 synchronized 中再进行一次 instance == null 判断，这种方式称为双重检查锁定（Double-Check Locking）。完整代码如下：\npublic class LazySingleton { private volatile static LazySingleton instance = null; private LazySingleton() { } synchronized public static LazySingleton getInstance() { // 第一重判断 if(instance == null) { // 锁定代码块 synchronized (LazySingleton.class) { // 第二重判断 if(instance == null) { instance = new LazySingleton(); // 创建单例实例 } } } return instance; } } 需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量 instance 之前增加修饰符 volatile，被 volatile 修饰的成员变量可以确保多个线程都能正确处理。由于 volatile 关键字会屏蔽 Java 虚拟机所做的一些代码优化，可能会导致系统的运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方法。\n饿汉式单例类与懒汉式单例类的比较 # 饿汉式单例类在类加载时就将自己实例化，它的优点在于无需考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。从资源利用率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。\n懒汉式单例在第一次使用时创建，无需一直占用系统资源，实现了延迟加载，但是必须处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然设计资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。\n使用静态内部类实现单例模式 # 饿汉式单例和懒汉式单例都存在一些问题，为了克服这些问题，在 Java 语言中可以通过 Initialization on Demand Holder（IoDH）技术来实现单例模式。\n在 IoDH 中，需要在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过 getInstance() 方法返回给外部使用，实现代码如下：\n// Initialization on Demand Holder(IoDH) public class Singleton { private Singleton(){ } // 静态内部类 private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } public static void main(String args[]){ Singleton s1,s2; } } 由于静态单例对象没有作为 Singleton 的成员变量直接实例化，因此类加载时不会实例化 Singleton，第一次调用 getInstance() 时将加载内部类 HolderClass，在该内部类中定义了一个 static 类型的变量 instance，此时会首先初始化这个成员变量，由 Java 虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于 getInstance() 方法没有任何线程锁定，因此其性能不会造成任何影响。\n单例模式优点 # 单例模式提供了对唯一实例的受控访问。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 允许可变数目的实例。基于单例模式可以进行扩展，使用与控制单例对象相似的方法来获得指定个数的实例对象，即节省系统资源，又解决了由于单例对象共享过多有损性能的问题。 单例模式缺点 # 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的指责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。 大部分面向对象语言都提供了垃圾回收技术，因此如果实例化的共享对象长时间不利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这导致共享的单例对象状态的丢失。 单例模式使用环境 # 系统只需要一个实例对象，例如系统要求提供一个唯一的序列化生成器或资源管理器等。 客户调用类的单个实例只允许使用一个公共访问点，除了公共访问点，不能通过其他途径访问该实例。 ","date":"2024-7-17","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater08/","section":"Posts","summary":"","title":"08-单例模式","type":"posts"},{"content":" 原型模式概述 # 在面向对象系统中可以通过复制一个原型对象得到多个与原型对象一模一样的新对象，这就是原型模式的动机。\n原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\nPrototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\n原型模式是一种对象创建型模式，它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。\n需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改不会对原型对象造成任何影响，每一个克隆对象都是相互独立的。\n原型模式结构 # 原型模式结构如下图所示：\n原型模式结构图 由上图可知，原型模式包含以下 3 个角色。\nPrototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是借口，甚至还可以是具体实现类。 ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 Client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法得到多个相同的对象。由于客户类针对抽象原型类 Prototype 编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 浅克隆与深克隆 # 浅克隆\n如果原型对象的成员变量是值类型（基本数据类型），将复制一份给克隆对象；如果原型对象的成员变量是引用类型，将引用对象的地址（内存引用地址）复制一份给克隆对象。\n当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。\n浅克隆示意图 深克隆\n不论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象。也就是除了对象本身，对象所包含的所有成员变量也将被复制。\n深克隆示意图 原型模式实现 # 通过实现方法 # 通用的克隆实现方法是在具体原型的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。\npublic abstract class Prototype { public abstract Prototypr cloen(); } public class ConcretePrototypr extends Prototype { private String attr;\t// 成员变量 public void setAttr(String attr) { this.attr = attr; } public String getAttr() { return this.attr; } // 克隆方法 public Prototype clone() { Prototype prototype = new Prototype(); // 创建新对象 prototype.setAttr(this.attr); return prototype; } } 在客户类中只需要创建一个 ConcretePrototype 对象作为原型对象，然后调用其 cloen() 方法即可得到对象的克隆对象，例如：\n... ConcretePrototype prototype = new ConcretePrototype(); prototype.setAttr(\u0026#34;Sunny\u0026#34;); ConcretePrototype copy = (ConcretePrototype)prototype.clone(); ... 此方法是原型模式的通用实现，它与编程语言本身的特性无关，其他面向编程语言也可以使用这种形式来实现对原型对象的克隆。\nJava 语言中的 clone() 方法和 Cloneable 接口 # 在 Java 语言中，Object 类提供了一个 clone() 方法，可以将一个 Java 对象复制一份。因此在 Java 中可以直接使用 Object 提供的 clone() 方法实现浅克隆。\n能够实现克隆的 Java 类必须实现一个标识接口 Cloneable，表示这个 Java 类支持被复制。如果没有实现这个接口，Java 编译器将抛出一个 CloneNotSupportedException 异常。\npublic class ConcretePrototype implements Cloneable { ... public Prototype clone() { Object object = null; try { object = super.clone();\t// 浅克隆 } catch(CloneNotSuppertedException exception) { System.err.println(\u0026#34;Not support cloneable\u0026#34;); } return (Prototype)object; } ... } 在客户端创建原型对象和克隆对象也很简单。\nPrototype prototype = new Prototype(); Prototype copy = prototype.clone(); Java 语言中的 clone() 方法满足以下几点：\n对任何对象 x，都有 x.clone() != x，即克隆对象和原型对象不是同一个对象。 对任何对象 x，都有 x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样。 如果对象的 x 的 equles() 方法定义恰当，那么 x.clone().equals(x) 应该成立。 为了获取对象的一个克隆，可以直接利用 Object 类的 clone() 方法，具体步骤如下：\n在派生类中覆盖基类的 clone() 方法，并声明为 public。 在派生类的 clone() 方法中调用 super.clone()。 派生类需实现 Cloneable 接口。 此时，Object 类相当于抽象原型类，所有实现了 Cloneable 接口的类相当于具体原型类。\n原型模式应用实例 # 实例说明 # 在使用某 OA 系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。\n试使用原型模式对该 OA 系统中的工作周报创建模块进行改进。\n实例类图 # 通过分析，本实例的结构图如下：\n工作周报创建模块结构图（浅克隆） 实例代码 # Attachment：附件类\npublic class Attachment { private String name; // 附件名 public void setName(String name) { this.name = name; } public String getName() { return this.name; } public void download() { System.out.println(\u0026#34;下载附件，文件名为 \u0026#34; + name); } } WeeklyLog：工作周报类，充当原型角色。在真实环境下该类将比较复杂，考虑到代码的可读性，在此只列出部分与模式相关的核心代码。\npublic class WeeklyLog implements Cloneable { // 为了简化设计和实现，假设一份工作周报中只有一个附件对象，在实际情况中可以包含多个附件，可以通过 List 等集合对象来实现 private Attachment attachment; private String name; private String date; private String content; public Attachment getAttachment() { return attachment; } public void setAttachment(Attachment attachment) { this.attachment = attachment; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } // 使用 clone() 方法实现浅克隆 public WeeklyLog clone() { Object obj = null; try { obj = super.clone(); return (WeeklyLog) obj; } catch (CloneNotSupportedException e) { System.out.println(\u0026#34;不支持复制\u0026#34;); return null; } } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { WeeklyLog log_previous, log_new; log_previous = new WeeklyLog(); // 创建原型对象 Attachment attachment = new Attachment(); // 创建附件对象 log_previous.setAttachment(attachment); // 将附件添加到周报中 log_new = log_previous.clone(); // 调用克隆方法创建克隆对象 // 比较周报 System.out.println(\u0026#34;周报是否相同？\u0026#34; + (log_previous == log_new)); // 比较附件 System.out.println(\u0026#34;附件是否相同？\u0026#34; + (log_previous.getAttachment() == log_new.getAttachment())); } } 结果及分析 # 编译并运行程序，输出结果如下，此方式仅仅实现了对象的浅克隆。\n周报是否相同？false 附件是否相同？true 深克隆解决方案 # 在 Java 语言中可以通过序列化（Serialization）等方式来实现深克隆。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存在于内存中。通过序列化将对象写到一个流中，再从流中将其读出来，可以实现深克隆。需要注意能够实现序列化的对象其类必须实现实现 Serialization 接口。\n下面是用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写入流中，因此两个类均要实现 Serializable 接口，其结构如下图所示：\n工作周报创建模块结构图（深克隆） 修改后的附件类 Attachment 的代码如下：\npublic class Attachment implements Serializable { private String name; // 附件名 public void setName(String name) { this.name = name; } public String getName() { return this.name; } public void download() { System.out.println(\u0026#34;下载附件，文件名为 \u0026#34; + name); } } 工作周报类 WeeklyLog 不再使用 Java 自带的克隆机制，而是通过序列化从头实现对象的深克隆，编写 deepClone() 方法实现深克隆。\npublic class WeeklyLog implements Serializable { private Attachment attachment; private String name; private String date; private String content; public Attachment getAttachment() { return attachment; } public void setAttachment(Attachment attachment) { this.attachment = attachment; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } // 使用序列化技术实现深克隆 public WeeklyLog deepClone() throws IOException, ClassNotFoundException, OptionalDataException { // 将对象写入流中 ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(this); // 将对象从流中取出 ByteArrayInputStream bis = new ByteArrayInputStream(bao.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (WeeklyLog) ois.readObject(); } } 客户端测试类 Client 的代码修改如下：\npublic class Client { public static void main(String[] args) { WeeklyLog log_previous, log_new = null; log_previous = new WeeklyLog(); // 创建原型对象 Attachment attachment = new Attachment(); // 创建附件对象 log_previous.setAttachment(attachment); // 将附件添加到周报中 try { log_new = log_previous.deepClone(); // 调用深克隆方法创建克隆对象 } catch (Exception e) { System.out.println(\u0026#34;克隆失败\u0026#34;); } // 比较周报 System.out.println(\u0026#34;周报是否相同？\u0026#34; + (log_previous == log_new)); // 比较附件 System.out.println(\u0026#34;附件是否相同？\u0026#34; + (log_previous.getAttachment() == log_new.getAttachment())); } } 输出结果如下：\n周报是否相同？false 附件是否相同？false 原型管理器 # 原型管理器（Prototype Manager）将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对爱那个的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中对原型类进行编程，以便扩展。\n带原型管理器的原型模式 典型的原型管理器 PrototypeManager 类的实现代码片段如下：\nimport java.util.*; public class PrototypeManager { private Hashtable prototypeTable = new Hashtable(); // 使用 Hashtable 存储原型对象 public PrototypeManager() { prototypeTable.put(\u0026#34;A\u0026#34;, new ConcretePrototypeA()); prototypeTable.put(\u0026#34;B\u0026#34;, new ConcretePrototypeA()); } public void add(String key, Prototype prototype) { prototypeTable.put(key, prototype); } public Prototype get(String key) { Prototype clone = null; clone = ((Prototype) prototypeTable.get(key)).clone(); // 通过克隆方法创建新对象 return clone; } } 在实际开发中可以将 PrototypeManager 设计为单例类，确保系统中只有一个 PrototypeManager 对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。\n原型模式优点 # 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统没有任何影响。 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个产品等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无需专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（例如恢复到某一历史状态），可辅助实现撤销操作。 原型模式缺点 # 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时需要修改源代码，违背了开闭原则。 在实现深克隆时需要便携较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现比较麻烦。 原型模式适应环境 # 创建新对象成本较大，新对象可以通过复制已有对象来获得。 系统要保存对象的状态，而对象的状态变化很小。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制对象得到新实例可能比使用构造函数构造一个新实例更加方便。 ","date":"2024-7-15","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater07/","section":"Posts","summary":"","title":"07-原型模式","type":"posts"},{"content":" 创造者模式概述 # 建造者模式可以将部分本身和它们得组装过程分开，关注如何一步一步地创建一个包含多个组成部分得复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无需知道其内部的具体构造细节。\n建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\nBuilder Pattern: Separate the construction of a complex object from its representation so that the same construction process can create different representations.\n建造者模式结构 # 建造者模式的结构如下图所示：\n建造者模式结构图 由上图可知，建造者模式包含以下 4 个角色。\nBuilder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是 buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是 getResult()，它们用于返回复杂对象。Builder 既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了 Builder 接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。 Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装备过程。 Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其 construct() 建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制实现），然后通过指挥者类的构造函数或者 Setter 方法将该对象传入指挥者类中。 建造者模式实现 # 在建造者模式的定义中提到了复杂对象，那什么是复杂对象呢？简单来说，复杂对象是指那些包含多个成员变量的对象，这些成员变量也称为部件或零件。一个典型的复杂对象类的代码示例如下：\npublic class Product { private String partA; // 定义部件，部件可以是任意类型，包括值类型和引用类型 private String partB; private String partC; // partA的Getter方法和Setter方法省略 // partB的Getter方法和Setter方法省略 // partC的Getter方法和Setter方法省略 } 在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：\npublic abstract class Builder { // 创建产品对象 protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); // 返回产品对象 public Product getResult() { return product; } } 在抽象类 Builder 中声明了一系列抽象的 buildPartX() 方法，用于创建复杂产品的各个部件，具体创造过程在 ConcreteBuilder 中实现，此外还提供了工厂方法 getResult()，用于返回一个已创建好的完整产品对象。\n在 ConcreteBuilder 中实现了这些 buildPartX() 方法，通过调用 Product 的 setPartX() 方法可以给产品对象的成员变量设值，不同的具体建造者在实现 buildPartX() 方法时有所区别，例如 setPartX() 方法的参数可能不一样，在有些具体建造者类中某些 setPartX() 方法无需实现（提供一个空实现）。而这些对于客户端来说都无需关心，客户端只需知道具体建造者类型即可。典型的具体建造者类代码如下：\npublic class ConcreteBuilder1 extends Builder { public void buildPartA() { product.setPartA(\u0026#34;A1\u0026#34;); } public void buildPartB() { product.setPartB(\u0026#34;B1\u0026#34;); } public void buildPartC() { product.setPartC(\u0026#34;C1\u0026#34;); } } 此外，在建造者模式中还引入了一个指挥者类 Director，该类主要有两个作用：一方面它隔离了客户端与创建过程；另一方面它控制产品对象的创建过程，包括某个 buildPartX() 方法是个被调用以及多个 buildPartX() 方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型便可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。指挥者的示例代码如下：\npublic class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void setBuilder(Builder builder) { this.builder = builder; } // 产品构建和组装方法 public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } 在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法 construct()，在该方法中调用了 builder 对象的构造部件的方法，最后返回一个产品对象。\n对于客户端而言，只需要关心具体建造者的类型，无需关心产品对象的具体组装过程。通常，客户类代码片段如下：\n... Builder builder = new ConcreteBuilder1(); // 可通过配置文件实现 Director director = new Director(builder); Product product = director.construct(); ... 可以通过配置文件来存储具体建造者类 ConcreteBuilder1 的类名，使得在更换新的建造者时无需修改源代码，系统扩展更方便。\n建造者模式与抽象工厂模式都是较为复杂的创建型模式，建造者模式返回一个完整的复杂产品，抽象工厂模式返回一系列相关的产品；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型来指导 Director 类如何去生成对象，侧重于一步步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个骑车配件生产厂，生成不同类型的骑车配件，那么建造者模式就是一个骑车组装常，通过对配件进行组装返回一辆完整的汽车。\n建造者模式应用实例 # 实例说明 # 某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。\n作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、脸型等多个组成部分，不同类型的游戏角色，其性别、脸型、服装、发型等外部特征都有所差异，例如“天使”拥有着美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”及其丑陋，留着光头并穿着一件刺眼的黑衣。\n无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。\n试使用建造者模式来实现游戏角色的创建。\n实例类图 # 通过分析，本实例的结构如图所示：\n游戏角色创建结构图 实例代码 # Actor：游戏角色类，充当复杂产品对象。考虑到代码的可读性，在此只列出部分成员变量，且成员变量的类型均为 String，在真实情况下，有些成员变量的类型需要自定义。\npublic class Actor { private String type; // 角色类型 private String sex; // 性别 private String face; // 脸型 private String costume; // 服装 private String hairstyle; // 发型 public void setType(String type){ this.type = type; } public void setFace(String face){ this.face = face; } public void setSex(String sex) { this.sex = sex; } public void setCostume(String costume){ this.costume = costume; } public void setHairstyle(String hairstyle) { this.hairstyle = hairstyle; } public String getType() { return type; } public String getSex() { return sex; } public String getFace() { return face; } public String getCostume() { return costume; } public String getHairstyle() { return hairstyle; } } ActorBuilder：游戏角色创建者，充当抽象建造者。\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 工厂方法，返回一个完整的游戏角色对象 public Actor createActor() { return actor; } } HeroBuilder：英雄角色建造者，充当具体建造者。\npublic class HeroBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;英雄\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;男\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;英俊\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;盔甲\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;飘逸\u0026#34;); } } AngleBuilder：天使角色建造者，充当具体建造者。\npublic class AngleBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;天使\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;女\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;漂亮\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;白裙\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;披肩长发\u0026#34;); } } DevilBuilder：恶魔角色建造者，充当具体建造者。\npublic class DevilBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;恶魔\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;妖\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;丑陋\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;黑衣\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;光头\u0026#34;); } } ActorController：角色控制器，充当指挥者。\npublic class ActorController { // 逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); actor = ab.createActor(); return actor; } } 配置文件 config.xml，在配置文件中存储了具体建造者类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.builder.AngleBuilder\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\n// 将 XML 工具类提取到 utils 包中，传入config.xml 文件路径，方便使用 package com.wangyq.utils; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import java.io.File; public class XMLUtil { public static Object getBean(String filePath) { try { // 创建 DOM 文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(filePath)); // 获取包含类名的文本结点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { ActorBuilder ab; // 针对抽象建造者编程 ab = (ActorBuilder) XMLUtil.getBean(\u0026#34;design-pattern/src/main/java/com/wangyq/builder/config.xml\u0026#34;); // 反射生成具体建造者对象 ActorController ac = new ActorController(); Actor actor; actor = ac.construct(ab); // 通过指挥者创建完整的建造者对象 String type = actor.getType(); System.out.println(type + \u0026#34;的外观：\u0026#34;); System.out.println(\u0026#34;性别：\u0026#34; + actor.getSex()); System.out.println(\u0026#34;面容：\u0026#34; + actor.getFace()); System.out.println(\u0026#34;服装：\u0026#34; + actor.getCostume()); System.out.println(\u0026#34;发型：\u0026#34; + actor.getHairstyle()); } } 结果及分析 # 编译并运行程序，输出结果如下：\n天使的外观： 性别：女 面容：漂亮 服装：白裙 发型：披肩长发 如果需要更换具体角色建造者，只需要修改配置文件即可。\n当需要增加新的具体角色建造者时只需要将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件，原有代码无需修改，完全符合开闭原则。\n指挥者类的深入讨论 # 指挥者类 Director 是建造者模式的重要组成部分，简单的 Director 类用于指导具体建造者如何构建产品，它按一定次序调用 Builder 的 buildPartX() 的方法，控制调用的先后次序，并向客户端返回一个完整的产品对象。下面讨论几种 Director 的变化形式。\n省略 Director # 在有些情况下，为了简化系统结构，可以将 Director 和抽象建造者 Builder 进行合并，在 Builder 中提供逐步构建复杂产品对象的 construct() 方法。由于 Builder 类通常为抽象类，因此可以将 construct() 方法定义为静态（static）方法，以便客户端能够直接调用。如果将游戏角色实例中的指挥者类 ActorController 省略，ActorBuilder 类的代码修改如下：\npublic abstract class ActorBuilder { protected static Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public static Actor construct(ActorBuilder ab) { ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); return actor; } } 此时对应的客户端代码也将发生修改，代码片段如下：\n... ActorBuilder ab; ab = (ActorBuilder) XMLUtil.getBean(); Actor actor; actor = ActorBuilder.construct(ab); ... 除此之外，还有一种更简单的处理方式，可以将 construct() 方法中的参数去掉，直接在 construct() 方法中调用 buildPartX() 方法，代码如下：\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public Actor construct() { this.buildType(); this.buildSex(); this.buildFace(); this.buildCostume(); this.buildHairstyle(); return actor; } } 客户端代码片段如下：\n... ActorBuilder ab; ab = (ActorBuilder) XMLUtil.getBean(); Actor actor; actor = ab.construct(); ... 此时，construct() 方法定义了 buildPartX() 方法的调用次序，为 buildPartX() 方法的执行提供了一个流程模板，这与在后边要学习的模板方法非常类似。\n以上两种对 Director 类的省略方法都不影响系统的灵活性和可扩展性，同时还简化了系统结构，但加重了抽象建造者类的职责。如果 construct() 方法较为复杂，待构建产品的组成部分比较多，建议还是将 construct() 方法单独封装在 Director 中，这样更符合单一职责原则。\n钩子方法的引入 # 钩子方法（Hook Method）用来控制是否对某个 buildPartX() 进行调用。\n钩子方法的返回类型通常为 boolean 类型，方法名一般为 isXXX()，钩子方法定义在抽象建造者类中。例如可以在游戏角色的抽象建造者类 ActorBuilder 中定义一个方法 isBareheaded()，用于判断某个角色是否为“光头（Bareheaded）”，在 ActorBuilder 为之提供一个默认实现，代码如下：\npublic abstract class ActorBuilder { protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); // 钩子方法 public boolean isBareheaded() { return false; } public Actor createActor() { return actor; } } 如果某个角色无需构建头发部件，例如“恶魔”，则对应的具体建造器 DevilBuilder 将覆盖 isBareheaded() 方法，并将返回值改为 true，代码如下：\npublic class DevilBuilder extends ActorBuilder { @Override public void buildType() { actor.setType(\u0026#34;恶魔\u0026#34;); } @Override public void buildSex() { actor.setSex(\u0026#34;妖\u0026#34;); } @Override public void buildFace() { actor.setFace(\u0026#34;丑陋\u0026#34;); } @Override public void buildCostume() { actor.setCostume(\u0026#34;黑衣\u0026#34;); } @Override public void buildHairstyle() { actor.setHairstyle(\u0026#34;光头\u0026#34;); } // 覆盖钩子方法 public boolean isBareheaded() { return true; } } 同时，指挥者类 ActorController 的代码修改如下：\npublic class ActorController { // 逐步构建复杂产品对象 public Actor construct(ActorBuilder ab) { Actor actor; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); // 通过钩子方法来控制产品的构建 if(!ab.isBareHeaded()) { ab.buildHairstyle(); } actor = ab.createActor(); return actor; } } 当在客户端代码中置顶具体建造者类型并通过指挥者来实现产品的逐步构建时，将调用钩子方法 isBareheaded() 来判断游戏角色是否有头发，如果 isBareheaded() 方法返回 true，即没有头发，将跳过构建发型的方法 buildHairstyle()，否则将执行 buildHairstyle() 方法。\n通过引入钩子方法，可以在 Director 中对复杂产品的构建进行精细的控制，不仅指定 buildPartX() 方法的执行顺序，还可以控制是否需要执行某个 buildPartX() 方法。\n建造者模式优点： # 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因为可以很方便地替换具体建造者或增加新的具体建造，用户使用不同的具体建造者即可得到不同的产品对象。 可以更加精细地控制产品的创建过程。 建造者模式缺点： # 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。 建造者模式适用环境 # 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类将创建过程封装在指挥者类中，而不在建造者和客户类中。 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 ","date":"2024-7-12","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater06/","section":"Posts","summary":"","title":"06-建造者模式","type":"posts"},{"content":" 产品等级结构和产品族 # 工厂方法模式通过引入工厂等级结构解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个具体工厂只有一个或者一组重载的工厂方法，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。有时候可能需要一个工厂可以提供多种产品对象，而不是单一的产品对象，此时可以考虑将一些相关的产品组成一个“产品族”，由一个工厂来统一生产。\n为了更好地理解抽象工厂模式，先引入两个概念：\n产品等级结构：产品等级结构即产品的继承结构。 产品族：在抽象工厂模式中，产品族是指由同一工厂生产的位于不同产品等级结构中的一组产品。 产品等级结构和产品族示意图如下图所示：\n产品族与产品等级结构示意图 在上图中一共包含了 3 个产品族，分属于 3 个不同的产品等级结构，只要指明一个产品所处的产品族以及它所属的等级结构就可以唯一确定这个产品。\n抽象工厂模式概述 # 当系统所提供的工厂生产的具体产品不是一个见到那的对象，而是多个不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。\n抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构的一个产品族中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如下图所示：\n抽象工厂模式示意图 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。\n抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\nAbstract Factory Pattern: Provide an interface for creating familes of related or dependent objects without specifying their concrete classes.\n抽象工厂模式又称为工具（Kit）模式，它是一种对象创建型模式。\n抽象工厂模式结构 # 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图所示：\n抽象工厂模式结构图 由上图可知，抽象工厂模式包含以下 4 个角色：\nAbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生产一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 抽象工厂模式实现 # 在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以时接口，也可以是抽象类或者具体类。其典型代码如下：\npublic interface AbstractFactory { public AbstractProductA createProductA(); // 工厂方法一 public AbstractProductB createProductB(); // 工厂方法二 } 具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下：\npublic class ConcreteFactory1 extends AbstractFactory { // 工厂方法一 public AbstractProductA createProductA() { return new ConcreteProductA1(); } // 工厂方法二 public AbstractProductB createProductB() { return new ConcreteProductB1(); } } 与工厂方法模式一样，抽象工厂模式也可以为每一种产品提供一组重载的工厂方法，以不同的方式来创建产品对象。\n抽象工厂模式应用实例 # 实例说明 # 某软件公司要开发一套界面皮肤库，可以对基于 Java 的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天（Spring）风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天（Summer）风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如下图所示：\n界面皮肤库结构示意图 该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。\n实力类图 # 通过分析，本实例的结构图如下图所示：\n实例代码 # Button：按钮接口，充当抽象产品。\npublic interface Button { public void display(); } SpringButton：Spring 按钮类，充当具体产品。\npublic class SpringButton implements Button{ @Override public void display() { System.out.println(\u0026#34;显示浅绿色按钮。\u0026#34;); } } SummerButton：Summer 按钮类，充当具体产品。\npublic class SummerButton implements Button { @Override public void display() { System.out.println(\u0026#34;显示浅蓝色按钮。\u0026#34;); } } TextField：文本框接口，充当抽象产品。\npublic interface TextField { public void display(); } SpringTextField：Spring 文本框类，充当具体产品。\npublic class SpringTextField implements TextField{ @Override public void display() { System.out.println(\u0026#34;显示绿色边框文本框。\u0026#34;); } } SummerTextField：Summer 文本框类，充当具体产品。\npublic class SummerTextField implements TextField{ @Override public void display() { System.out.println(\u0026#34;显示蓝色边框文本。\u0026#34;); } } ComboBox：组合框接口，充当抽象产品。\npublic interface ComboBox { public void display(); } SpringComboBox：Spring 组合框类，充当具体产品。\npublic class SpringComboBox implements ComboBox{ @Override public void display() { System.out.println(\u0026#34;显示绿色边框组合框。\u0026#34;); } } SummerComboBox：Summer 组合框类，充当具体产品。\npublic class SummerComboBox implements ComboBox{ @Override public void display() { System.out.println(\u0026#34;显示蓝色边框组合框。\u0026#34;); } } SkinFactory：界面皮肤工厂接口，充当抽象工厂。\npublic interface SkinFactory { public Button createButton(); public TextField createTextField(); public ComboBox createComboBox(); } SpringSkinFactory：Spring 皮肤工厂，充当具体工厂。\npublic class SpringSkinFactory implements SkinFactory{ @Override public Button createButton() { return new SpringButton(); } @Override public TextField createTextField() { return new SpringTextField(); } @Override public ComboBox createComboBox() { return new SpringComboBox(); } } SummerSkinFactory：Summer 皮肤工厂，充当具体工厂。\npublic class SummerSkinFactory implements SkinFactory { @Override public Button createButton() { return new SummerButton(); } @Override public TextField createTextField() { return new SummerTextField(); } @Override public ComboBox createComboBox() { return new SummerComboBox(); } } 配置文件 config.xml，在配置文件中存储了具体工厂类的类名。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;com.wangyq.abstractfactory.SpringSkinFactory\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; XMLUtil：工具类\npublic class XMLUtil { //该方法用于从XML配置文件中提取具体类类名， 并返回一个实例对象 public static Object getBean() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/abstractfactory/config.xml\u0026#34;)); //获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); //通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } } Client：客户端测试类\npublic class Client { public static void main(String[] args) { // 使用抽象层定义 SkinFactory factory; Button bt; TextField tf; ComboBox cb; factory = (SkinFactory) XMLUtil.getBean(); bt = factory.createButton(); tf = factory.createTextField(); cb = factory.createComboBox(); bt.display(); tf.display(); cb.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n显示浅绿色按钮。 显示绿色边框文本框。 显示绿色边框组合框。 如果需要更换皮肤，只需要修改配置文件即可。\n如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件中的具体工厂类名即可使用新的皮肤，原有代码无需修改，符合开闭原则。\n开闭原则的倾斜性 # 在抽象工厂模式中增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为开闭原则的倾斜性。开闭原则要求对扩展开放，对修改关闭，通过扩展达到增强其功能的目的，对于涉及多个产品族与多个产品等级结构的系统，其功能增强包括两个方面。\n增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无需做任何修改。 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，它以一种倾斜的方式来满足开闭原则，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够考虑全面，不会在设计完成之后再向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。\n抽象工厂模式优/缺点与使用环境 # 抽象工厂模式是工厂方法模式的进一步眼神，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和 API 类库的设计中。\n抽象工厂模式优点 # 抽象工厂模式隔离了具体类的生产，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对榕溪，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无需修改已有系统，符合开闭原则。 抽象工厂模式缺点 # 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不变，违背了开闭原则。\n抽象工厂模式适用环境 # 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无需关系对象的创建过程，将对象的创建和使用解耦。 系统中有多于一个的产品族，而每次只是用其中某一产品族。可以通过配置文件等方式来使用户能够动态改变产品族，也可以很方便地增加新的产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 ","date":"2024-7-10","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater05/","section":"Posts","summary":"","title":"05-抽象工厂模式","type":"posts"},{"content":" 工厂方法模式概述 # 简单工厂模式在新增一个类型时，需要修改工厂类的代码，使得整个设计在一定程度上违反了开闭原则。工厂方法模式通过引入抽象的工厂类，使得它在新增类型时不需要修改具体的工厂类就可以创建，让系统更加符合开闭原则。\n在工厂方法模式中不再提供一个同一个的工厂类来创建所有的产品对象，二是针对不同的产品提供不同的工厂，系统提供一个与产品等级接口对应的工厂等级结构。\n工厂方法模式：定义一个用于创建实例对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。\nFactory Method Pattern: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n工厂方法模式简称为工厂模式（Factory Pattern），又可称作虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern）。工厂方法模式时一种类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n工厂方法模式结构 # 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。结构图如下所示：\n工厂方法模式结构图 由上图可知，工厂方法模式包含以下 4 个角色：\nProduct（抽象产品）：它时定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品一一对应。 Factory（抽象工厂）：在抽象工厂类中声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 工厂方法模式实现 # 与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下：\npublic interface Factory { public Product factoryMethod(); } 在抽象工厂中声明了工厂方法单并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。其典型代码如下：\npublic class ConcreteFactory implement Factory { public Product factoryMethod() { return new ConcreteProduct(); } } 在实际使用时，具体工厂类在实现工厂方法时处理创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件都能。\n在客户端代码中，开发人员只需关心工厂类接口，不同的具体工厂可以创建不同的产品。典型的客户端代码片段如下：\n... Factory factory; factory = new ConcreteFactory(); // 可通过配置文件与反射机制实现 Product product; product = factory.factoryMethod(); ... 可以通过配置文件来存储具体工厂类 ConcreteFactory 的类名，再通过反射机制创建具体工厂对象，在更换新的具体工厂时无需修改源代码，系统扩展更方便。\n举个例子 # 实例说明 # 某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置由严格的先后顺序，否则可能会发生记录失败。\n为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统（注：在 Java 中常用的日志记录工具有 SLF4J、Log4j、GCLogViewer、Logstash 等）。\n实例类图 # 通过分析，本实例结构如下图所示：\n日志记录器结构图 Logger 接口充当抽象产品，其子类 FileLogger 和 DatabaseLogger 充当具体产品，LoggerFactory 接口充当抽象工厂，其子类 FileLoggerFactory 和 DatabaseLoggerFactory 充当具体工厂。\n实例代码 # Logger：日志记录器接口，充当抽象产品角色。\npublic interface Logger { public void writeLog(); } DatabaseLogger：数据库日志记录器，充当具体产品角色。\npublic class DatabaseLogger implements Logger { @Override public void writeLog() { System.out.println(\u0026#34;数据库日志记录。\u0026#34;); } } FileLogger：文件日志记录器，充当具体产品角色。\npublic class FileLogger implements Logger { @Override public void writeLog() { System.out.println(\u0026#34;文件日志记录。\u0026#34;); } } LoggerFactory：日志记录工厂接口，充当抽象工厂角色\npublic interface LoggerFactory { public Logger createLogger(); // 抽象工厂方法 } DatabaseLoggerFactory：数据库日志记录器工厂类，充当具体工厂角色。\npublic class DatabaseLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 连接数据库，代码省略 // 创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } } FileLoggerFactory：文件日志记录器工厂类，充当具体工厂角色。\npublic class FileLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 创建文件日志记录器对象 Logger logger = new FileLogger(); // 创建文件，代码省略 return logger; } } Cilent：客户端测试类。\npublic class Client { public static void main(String[] args) { LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); // 可引入配置文件和反射机制实现 logger = factory.createLogger(); logger.writeLog(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n文件日志记录。 如果需要增加并使用新的日志记录器，只需要对应增加一个新的具体工厂类，然后在客户端代码中修改具体工厂类的类名，原有类库的源代码无需做任何修改。\n通过引入配置文件并使用反射机制可以实现在不修改客户端代码的基础上更换具体工厂类，让系统用更加符合开闭原则，具备更好的灵活性和可扩展性。\n反射机制与配置文件 # 上面的实例中，在更换日志记录器时需要修改客户端代码，对于客户端而言并不符合开闭原则，本节将介绍如何在不修改客户端代码的基础上更换或增加新的日志记录方式。\n在实际应用开发中，可以对具体工厂类的实例化过程进行修改，在客户端代码中不直接使用 new 关键字来创建工厂对象，而是通过 Java 反射机制结合配置文件（例如 XML 文件）来生成具体工厂对象。\nJava 反射机制\nJava 反射（Java Reflection）是指在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等。\n// 通过类名生成实例对象并将其返回 Class c = Class.forName(\u0026#34;java.lang.String\u0026#34;); Object obj = c.newInstence(); return obj; 配置文件\n软件系统的配置文件通常为 XML 文件，可以使用 DOM（Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）等技术来处理 XML 文件。\n在软件开发中可以把类名存储到 XML 配置文件中，再读取配置文件获取类名字符串，然后通过 Java 反射机制来创建对象。\n\u0026lt;!-- config.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;className\u0026gt;designpatterns.factorymethod.FileLoggerFactory\u0026lt;/className\u0026gt; \u0026lt;/config\u0026gt; 为了读取该配置文件，并通过存储再其中的类名字符串反射生成对象，可以创建一个工具类 XMLUtil，其详细代码如下：\nimport org.w3c.dom.*; import javax.xml.parsers.*; import java.io.File; public class XMLUtil { // 该方法用于从 XML 配置文件中提取具体类的类名，并返回一个实例对象 public static Object getBean() { try { // 创建 DOM 文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\u0026#34;design-pattern/src/main/java/com/wangyq/factorymethod/config.xml\u0026#34;)); // 获取包含类名的文本结点 NodeList nl = doc.getElementsByTagName(\u0026#34;className\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; } catch (Exception e) { e.printStackTrace(); return null; } } public static void main(String[] args) { Object bean = getBean(); String simpleName = bean.getClass().getSimpleName(); System.out.println(simpleName); } } 有了 XMLUtil 类之后，可以对日志记录器的客户端代码进行修改，不再直接使用 new 关键字来创建具体的工厂类，而是将 具体 工厂列的类名存储在 XML 文件中，再通过 XMLUtil 类的静态工厂方法 getBean() 进行对象的实例化，将代码修改如下：\npublic class Client { public static void main(String[] args) { LoggerFactory factory; Logger logger; factory = (LoggerFactory) XMLUtil.getBean(); // getBean() 的返回类型为 Object，需要进行强制类型转换 logger = factory.createLogger(); logger.writeLog(); } } 在引入 XMLUtil 类和 XML 配置文件之后，如果需要增加一种新类型的日志记录方式，只需要执行以下 4 个步骤：\n新的日志记录器需要继承抽象日志记录器 Logger； 对应增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂 LoggerFactory，并实现其中的工厂方法 createLogger()，设置好初始化参数和环境变量，返回具体日志记录器对象。 修改配置文件 config.xml，用新增的具体日志记录器工厂类的类名字符串替换原有工厂类的类名字符串。 编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合开闭原则。 工厂方法的重载 # 在某些情况下，可以通过多种方式来初始化同一个产品类。此时可以提供一个重载的工厂方法，以不同的方式对产品对象进行创建。对于同一个具体工厂而言，无论使用哪个工厂方法，所创建的产品类型均要相同。重载的工厂方法结构图如下图所示：\n重载的工厂方法结构图 引入重载方法后，抽象工厂类 LoggerFactory 的代码修改如下：\npublic interface LoggerFactory { public Logger createLogger(); // 抽象工厂方法 public Logger createLogger(String args); public Logger createLogger(Object obj); } 具体工厂类 DatabaseLoggerFactory 的代码修改如下：\npublic class DatabaseLoggerFactory implements LoggerFactory { @Override public Logger createLogger() { // 使用默认方式连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } @Override public Logger createLogger(String args) { // 使用参数 args 作为连接字符串来连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; } @Override public Logger createLogger(Object obj) { // 使用封装在参数 obj 中的连接字符串来连接数据库，代码省略 Logger logger = new DatabaseLogger(); // 使用封装在参数 obj 中的数据来初始化数据库日志记录器，代码省略 return logger; } } // 其他具体工厂类代码省略 工厂方法的隐藏 # 有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时在工厂类中直接调用产品类的业务方法，客户端无需调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。\n如果对客户端隐藏工厂方法，那么日志记录器结构图可修改为如下图所示\n隐藏工厂方法后的日志记录器结构图 抽象工厂类的代码修改如下：\n// 将接口改为抽象类 public abstract class LoggerFactory { // 在工厂类中直接调用日志记录器的业务方法 writeLog() public void writeLog() { Logger logger = this.createLogger(); logger.writeLog(); } public abstract Logger createLogger(); } 客户端代码修改如下：\npublic class Client { public static void main(String[] args) { LoggerFactory factory; factory = (LoggerFactory) XMLUtil.getBean(); factory.writeLog(); // 直接使用工厂对象来调用产品对象的业务方法 } } 工厂方面模式优/缺点与适应环境 # 工厂方法模式优点 # 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部。 使用工厂方法模式的另一个优点是在系统中加入新产品时无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他大的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样系统的可扩展性也就变的非常好，完全符合开闭原则。 工厂方法模式的缺点 # 在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成增加，在一定程度上增加了系统的复杂性，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 工厂方法模式适用环境 # 客户端不知道它所需要的对象的类。 抽象工厂类通过其子类来指定创建哪个对象。 ","date":"2024-7-8","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater04/","section":"Posts","summary":"","title":"04-工厂方法模式","type":"posts"},{"content":" 创建型模式 # 创建型模式（Creational Pattern）关注对象的创建过程，是一类常用的设计模式。创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例和创建细节，让用户在使用对象的时候无需关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。\n创建型模式一览表\n模式名称 定义 学习难度 使用频率 简单工厂模式（Simple Factory Pattern） 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类 ⭐⭐ ⭐⭐⭐ 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 ⭐⭐ ⭐⭐⭐⭐⭐ 抽象工厂方法（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 ⭐⭐⭐⭐ ⭐⭐⭐⭐⭐ 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 ⭐⭐⭐⭐ ⭐⭐ 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象 ⭐⭐⭐ ⭐⭐⭐ 单例模式（Singleton Pattern） 确保一个类只有一个实例 ⭐ ⭐⭐⭐⭐ 简单工厂模式概述 # 简单工厂模式的设计思想和实现过程都比较简单，其基本实现流程如下：\n首先将需要创建的各种不同产品对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需要调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。\n简单工厂模式（Simple Factory Pattern）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（Static Factory Method）模式。\n简单工厂模式结构 # 简单工厂模式包含以下 3 个角色\nFactory（工厂角色）：工厂角色即工厂类，他是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product。 Product（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 简单工厂模式结构图 简单工厂模式实现 # 在简单工厂模式中客户端通过工厂类来创建一个产品类的实例，而无须直接使用 new 关键字来创建对象，它是工厂模式家族中最简单的一员。\n在使用简单工厂模式时首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，一共不同的具体产品来实现。典型的抽象产品类代码的如下：\npublic abstract class Product { // 所有产品类的公共业务方法 public void methodSame() { // 公共方法的实现 } // 声明抽象业务方法 public abstract void methodDiff(); } 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。典型的具体产品类的代码如下：\npublic class ConcreteProduct extends Product{ // 实现业务方法 public void methodDiff() { // 业务方法的实现 } } 简单工厂模式的核心是工厂类，在没有工厂类之前客户端一般会使用 new 关键字来直接创建产品对象，而在引入工厂类之后客户端可以通过工厂类来创建产品，在简单工厂模式中工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。典型的工厂的代码如下：\npublic class Factory { // 静态工厂方法 public static Product getProduct(String arg){ if (arg.equalsIngoreCase(\u0026#34;A\u0026#34;)){ product = new ConcreateProductA(); // 初始化设置 product } else if (arg.equalsIgnoreCase(\u0026#34;B\u0026#34;)){ product = new ConcreateProductB(); // 初始化设置 product } return product; } } 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：\npublic class Client{ public static void main(String args[]){ Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;); // 通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); } } 举个例子 # 实例说明： # 某软件公司要基于 Java 语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart)等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。\n现使用简单工厂模式来设计图表库。\n实例类图 # 图表库结构图 上图中，Chart 接口充当抽象产品类，其子类 HistogramChart、PieChart 和 LineChart 充当具体产品类，ChartFactory 充当工厂类。\n实例代码 # Chart：抽象图表接口，充当抽象产品类。\npublic interface Chart { public void display(); } HistogramChart：柱状图类，充当具体产品类。\npublic class HistogramChart implements Chart { public HistogramChart() { System.out.println(\u0026#34;创建柱状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示柱状图！\u0026#34;); } } PieChart：饼状图类，充当具体产品类。\npublic class PieChart implements Chart { public PieChart() { System.out.println(\u0026#34;创建饼状图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示饼状图！\u0026#34;); } } LineChart：折线图类，充当具体产品类。\npublic class LineChart implements Chart { public LineChart() { System.out.println(\u0026#34;创建折线图！\u0026#34;); } @Override public void display() { System.out.println(\u0026#34;显示折线图！\u0026#34;); } } ChartFactory：图表工厂类，充当工厂类。\npublic class ChartFactory { // 静态工厂方法 public static Chart getChart(String type) { Chart chart = null; if (type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { chart = new HistogramChart(); System.out.println(\u0026#34;初始化设置柱状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { chart = new PieChart(); System.out.println(\u0026#34;初始化设置饼状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { chart = new LineChart(); System.out.println(\u0026#34;初始化设置折线图！\u0026#34;); } return chart; } } Client：客户端测试类。\npublic class Client { public static void main(String[] args) { Chart chart; chart = ChartFactory.getChart(\u0026#34;histogram\u0026#34;); // 通过静态方法创建产品 chart.display(); } } 结果及分析 # 编译并运行程序，输出结果如下：\n创建柱状图！ 初始化设置柱状图！ 显示柱状图！ 在客户端测试类中使用工厂类 ChartFactory 的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可。\n但是创建具体 Chart 对象时必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象，客户端代码需要重新编译，这对于客户端而言违反了开闭原则。\n一种常用的解决方案，可以将静态工厂方法的参数存储在 XML 等配置文件中，通过工具类读取配置文件中的字符串参数，更换图表时只需要改配置文件即可。\n简单工厂模式的简化 # 有时候，为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品中，如下图所示：\n简化的简单工厂模式 简单工厂模式优/缺点与适应环境 # 优点 # 工厂创建对象，客户端使用对象，实现了对象创建和使用的分离； 客户端无需知道创建的具体产品类的类名，可以在一定程度上减少使用者的记忆量； 通过引入配置文件，可以在不修改客户端代码的情况下更换和增加新的具体类，在一定程度上提高了系统的灵活性。 缺点 # 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响； 使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度； 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑。 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 # 工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂； 客户端只知道传入工厂类的参数，不关心如何创建对象。 ","date":"2024-7-5","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater03/","section":"Posts","summary":"","title":"03-简单工厂模式","type":"posts"},{"content":" 面向对象的设计原则概述 # 衡量软件质量的重要属性：\n可维护性（Maintainability）\n指软件能够被理解、改正、适应及扩展的难易程度；\n可复用性（Reusability）\n指软件能够被重复使用的难易程度。\n最常见的 7 个面向对象设计原则：\n设计原则名称 定义 使用频率 单一职责原则（Single Responsibility Principle，SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 ⭐⭐⭐⭐ 开闭原则（Open-Close Principle，OCP） 软件实体应带对扩展开放，对修改关闭 ⭐⭐⭐⭐⭐ 里氏代换原则（Liskov Substitution Principle，LSP） 所有引用基类的地方必须透明地使用其子类的对象 ⭐⭐⭐⭐⭐ 依赖倒转原则（Dependence Inversion Principle，DIP） 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 ⭐⭐⭐⭐⭐ 接口隔离原则（Interface Reuse Principle，IRP） 客户端不应该依赖那些它不需要的接口 ⭐⭐ 合成复用原则（Composite Reuse Principle，CRP） 优先使用对象组合，而不是通过继承来达到复用的目的 ⭐⭐⭐⭐ 迪米特法则（Law of Demeter，LoD） 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 ⭐⭐⭐ 单一职责原则 # 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。\n单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。\nSingle Responsibility Principle(SRP): Every object should hava a single responsibility, and that responsibility should be entirely encapsulated by the class.\n单一职责原则是实现高内聚、低耦合的指导方阵，它是最简单但又是最难运行的原则。\n例如：一个类，既要连接数据库，又要对表格进行操作，又要生成相关的统计图表。对于这个类，我们可以按照单一职责原则，将其拆分成三个类：用于连接数据库的工具类，用于操作数据库表的 DAO 类，用于生成图表并展示的类。\n开闭原则 # 开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。\n开闭原则：软件实体应当对扩展开放，对修改关闭。\nOpen-Close Principle(OCP): Software entities should be open for extension, but closed for modification.\n开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。\n为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。\n很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。\n里氏代换原则 # 以 Barbara Liskov（芭芭拉·利斯科夫）教授的姓氏命名，其严格表述如下：如果对每一个类型为 S 的对象 o1 都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换 o2 时程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。\n这个原始的定义不太容易理解，一般使用它的另一个通俗版定义：\n里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象。\nLiskov Subsitution Principle (LSP): Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\n里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。\n里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。\n依赖倒转原则 # 依赖倒转原则是面向对象设计的主要实现机制之一，是系统抽象化的具体实现。\n依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\nDependence Inversion Principle(DIP): High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.\n简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。\n依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，疯狗则将无法调用到在子类中增加的新方法。\n在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有的系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。\n在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependence Injection, DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，采用抽象的形式来注入所依赖的对象。常用的注入方式有 3 种，分别是构造注入、设值（Setter） 注入和接口注入。\n构造注入是指通过构造函数来传入具体类的对象。 设值注入是指通过 Setter 方法来传入具体类的对象。 接口注入是指通过在接口种声明的业务方法来传入具体类的对象。 大多数情况下，开闭原则、里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。\n接口隔离原则 # 接口隔离原则：客户端不应该依赖那些它不需要的接口。\nInterface Segregation Principle(ISP): Client should not be forced to depend upon interfaces that they do not use.\n当一个接口太大时需要将他分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。\n在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，在接口中仅包含为某一类用户定值的方法即可，不应该强迫客户依赖于那些他们不用的方法。\n合成复用原则 # 合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：\n合成复用原则：优先使用对象组合，而不是通过继承来达到复用的目的。\nComposite Reuse Principle(CRP): Favor composition of objects over inheritance as a reuse mechanism.\n在复用时尽量使用组合/聚合关系（关联关系），少用继承。\n如果两个类之间使“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可以使用继承。\n迪米特法则 # 迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP），其定义如下：\n迪米特法则：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\nLaw of Demeter(LoD): Each unit should have only limited knowledge about other units: only units \u0026ldquo;closely\u0026rdquo; related to the current unit.\n迪米特法则要求一个软件实体应当尽可能地与其他实体发生相互作用。\n迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don\u0026rsquo;t talk to strangers.）、只与你的直接朋友通信（Talk only to your immediate friends.）等。在迪米特法则中，对于一个对象，其朋友包括以下几类：\n当前对象本身（this）。 以参数形式传入到当前对象方法中的对象。 当前对象的成员对象。 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。 当前对象所创建的对象。 应用迪米特法则，可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。通过引入一个合理的“第三者”来降低现有对象之间的耦合度。\n将迪米特法则应用到系统设计中应注意以下几点：\n在类的划分上，尽量创建松耦合的类，有利于复用，松耦合的类一旦被修改，不会对关联的类造成太大影响。 在类的结构设计的上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 在类的设计上，只要有可能，一个类型应当设计成不变类； 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 ","date":"2024-7-4","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chpater02/","section":"Posts","summary":"","title":"02-面向对象设计原则","type":"posts"},{"content":" 设计模式的诞生与发展 # 模式的诞生与定义 # 模式（Pattern）起源于建筑业而非软件业，模式之父 \u0026ndash; Christopher Alexander 博士。\n模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案.\nA pattern is a successful or efficient solution to a recurring problem within a context.\n当一个领域逐渐成熟的时候自然会有很多模式。模式是一种直到，在一个良好的指导下有助于设计一个优良的解决方案，达到事半功倍的效果，而且会的到解决问题的最佳办法。\n最早将模式的思想引入软件工程学的是 1991-1992 年以“四人组”（Gang of Four，GOF，分别是 Erich Gamma、Richard helm、Ralph Johnson 和 John Vlissides）自称的 4 位著名软件工程学者。\nGoF 将模式的概念引入软件工程领域，这标志着软件模式的诞生。\n软件模式并非仅仅限于设计模式，还包括架构模式、分析模式和过程模式等。\n软件模式是在一定条件下的软件开发问题及其解法。软件模式的基本结构由 4 个部分构成，即问题描述、前提条件（环境或约束条件）、解法和效果，如下图所示。\n设计模式的定义与分类 # 设计模式的定义 # 设计模式（Design Pattern）是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解并且提高代码的可靠性。\nGoF 对设计模式的定义如下：\n设计模式是在特定环境下为解决某一通用软件设计问题提供的一套定值的解决方案，该方案描述了对象和类之间的相互作用。\nDesign patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.\n设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素有以下 4 个。\n模式名称（Pattern Name）\n通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的。\n问题（Problem）\n问题描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。在对问题进行描述的同时实际上就确定了模式所对应的使用环境以及模式的使用动机。\n解决方案（Solution）\n结局方案描述了设计模式的组成成分，以及这些组成成分的相互关系、各自的职责和协作方式。不针对具体问题，使用抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。\n效果（Consequences）\n效果描述了模式应用的效果以及在使用模式时应权衡的问题。没有一个解决方案是百分之百完美的，在使用设计模式时需要进行合理的评价和选择。\n设计模式的分类 # 设计模式一般有两种分类方式：\n根据目的分类\n分为创建型（Creational）、结构型（Structural）和行为型（Behavioral）三类。\n根据范围分类\n分为类模式和对象模式两种。\nGoF 设计模式简介 # GoF 的 23 种模式一览表 # 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法模式 （类）适配器模式 解释器模式模板方法模式 对象模式 抽象工厂模式建造者模式原型模式单例模式 （对象）适配器模式桥接模式组合模式装饰模式外观模式享元模式代理模式 职责链模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式 GoF 的 23 种设计模式的简要说明 # 模式类别 模式名称 模式说明 创建型模式（Creational Patterns） 抽象工厂模式（Abstract Factory Pattern） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样得构建过程可以创建不同的表示 工厂方法模式（Factory Method Pattern） 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类 原型模式（Prototype Pattern） 使用原型实例指定待创建对象的类型，并且通过复制这个原型来后创建新的对象 单例模式（Singleton Pattern） 确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例 结构型模式（Structural Patterns） 适配器模式（Adapter Pattern） 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作 桥接模式（Bridge Pattern） 将抽象部分与它的实例部分解耦，使得两者都能够独立变化 组合模式（Composite Pattern） 组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象 装饰模式（Decorator Pattern） 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供一种比使用子类更加灵活的替代方案 外观模式（Façade Pattern） 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 享元模式（Flyweight Pattern） 运用共享技术有效地支持大量细粒度对象的复用 代理模式（Proxy Pattern） 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问 行为型模式（Behavioral Patterns） 职责链模式（Chain of Responsibility Pattern） 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止 命令模式（Command Pattern） 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并给定一个解释器，这个解释器使用该表示来解释语言中的句子 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示 中介者模式（Mediator Pattern） 定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 备忘录模式（Memento Pattern） 在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以将对象恢复到原先保存的状态 观察者模式（Observer Pattern） 定义对象直接按的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知被自动更新 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 策略模式（Strategy Pattern） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它的客户而变化 模板方式模式（Template Method Pattern） 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 访问者模式（Visitor Pattern） 表示一个作用与某对象结构中的各个元素的操作。访问者模式可以在不改变各元素的类的前提下定义作用于这些元素的新操作 设计模式的优点 # 设计模式融合了众多专家的经验，并以一种标准的形式供广大开发人员所用，它提供了一套通用的设计词汇和一种通用的语言以方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。 设计模式使人们可以更加简单、方便地复用成功的设计和体系结构，将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 设计模式使得设计方案更加灵活，且易于修改。 设计模式的使用将提高软件系统的开发效率和软件质量，并且在一定程度上节约设计成本。 设计模式有助于初学者更深入地理解面向对象思想，一方面可以帮助初学者更加方便地阅读和学习现有类库与其他系统中的源代码，另一方面还可以提高软件的设计水平和代码质量。 ","date":"2024-7-3","externalUrl":null,"permalink":"/posts/restudyjavadesignpattern/chapter01/","section":"Posts","summary":"","title":"01-设计模式概述","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/hadoop/","section":"Tags","summary":"","title":"Hadoop","type":"tags"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/categories/hadoop/","section":"Categories","summary":"","title":"Hadoop","type":"categories"},{"content":"这篇文章并非原厂，是之前在网上找的，Hadoop MapReduce 的流程图，觉得很不错，就是网上的图太糊了，在这里重置一下。MR 作为大数据处理的基石，顺便梳理一下 MR 的流程。\nMapReduce 一共有 7 个角色参与，分为 4 个大阶段，7 个小阶段。分别是：\n任务启动阶段 由 Client 端发起请求； YarnRunner 接受请求并申请资源； ResourceManager 检索资源情况，分配资源路径给 YarnRunner； YarnRunner 进行分配，申请启动 MRAppMaster； ResourceManager 根据分片和 job 等信息，选择数据所在节点启动 MapTask（程序找数据），唤醒MRAppMaster； MRAppMaster 启动，持续监控和管理任务； MapTask 启动，开始干活； Map 阶段 数据读取，每个 task 读取自己节点上的数据； 数据处理 每个 task 对自己读取到的数据进行 split，分成更小的数据块； 对每个 split 的数据进行 map，提取 key、value、con； 对数据进行分区，有条件建议自定义分区，可以解决数据倾斜的问题，对之后的 reduce 也有极大的优化； 数据进入环形缓冲区，以起始点为赤道，到达溢出比后，刷新赤道； 溢出的数据刷入 sort 进行排序； 排序号的数据放入 spill，进行 merge 后有序写入 HDFS； Reduce 阶段 Reduce 启动 MRAppMaster 监控到 reduce 任务即将结束，开始申请启动 ReduceTask；RM 接受申请，根据分区结果，启动若干 ReduceTask。 ReduceTask启动，把每个 map 结果中的不同分区的数据，shuffle 数据到对应 ReduceTask 所在节点的缓存。 数据处理 在缓存中对每个 sotr 进行 merge（内存、缓存都有）； 将 merge 后的结果，重新进行 spill，排序后，落到 HDFS； 将所有小文件 merge 成一个大文件； Reduce 阶段 调用 Reduce 函数，对排序好的 file 进行汇总； 将最终结果写入到 HDFS 中； 任务结束阶段 MRAppMaster 监控到每个 Reduce 节点的执行情况； 向上汇报，并申请注销自己； RM 注销 MRAppMaster，并向上汇报； YarnRunner 返回任务完成信息； 客户端接受信息，任务结束。 整体流程图如下：\n\u0026hellip; 无奈，图片比较大，显示效果特别差，只能放链接了，后边想办法优化。\n链接：https://pan.baidu.com/s/1cF2CDo5NAzI7vOtQgvo_nw?pwd=r85y\n提取码：r85y\n","date":"2024-7-3","externalUrl":null,"permalink":"/posts/mr-image/","section":"Posts","summary":"","title":"MapReduce流程图（重制版）","type":"posts"},{"content":"","date":"2024-7-3","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/","section":"Tags","summary":"","title":"大数据","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/blog/","section":"Tags","summary":"","title":"Blog","type":"tags"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/categories/%E5%8D%9A%E5%AE%A2/","section":"Categories","summary":"","title":"博客","type":"categories"},{"content":" 选型 # 在 Hexo 和 Hugo 之间纠结了很久，开始尝试使用 Hexo 构建博客，搭建很快，主题很多，生成页面也比较漂亮，但是构建速度慢，外加没有找到自己喜欢的配色。再次尝试使用 Hugo 搭建，构建真快，主题也多，Blowfish 主题文档也全，使用体验真的没话说。\n前置条件 # 使用 Hugo 前，需要自己安装 Go 语言，Node.js，Git 等环境。安装很简单，本人是window系统，下载 amd64 位安装包，点点点，安装完成后验证就可以了。\nHugo 的安装需要注意，直接从 github 上下载 releases 版本的压缩包，解压缩后配置环境变量。Hugo 大部分主题都需要一些高级功能，所以直接下载 扩展版。\n配置好环境变量后，在 CMD 命令行查看是否安装成功。\nhugo version ## 出现如下提示，即为安装成功 hugo v0.128.0-e6d2712ee062321dc2fc49e963597dd5a6157660+extended windows/amd64 BuildDate=2024-06-25T16:15:48Z VendorInfo=gohugoio 开始搭建 # 其实 Hugo 中文文档 和 Blowfish 文档 已经很详细了，这里简要总结一下:\n使用 Hugo 构建项目 # Hugo new site your-site # your-site 请自行修改为自己的项目目录 cd your-site 注意，Hugo new site 要求文件夹必须为空，哪怕是有隐藏文件夹也会导致初始化失败。\n初始化后目录结构如下：\ngit init 各位可以先在 GitHub 上新建一个空白仓库，然后 git clone 下来。\nHugo new site your-site之后，将 .git 文件夹拷贝到 your-site 文件夹下，这样方便后续代码提交。\n安装主题 # 主题我这里使用的是 Blowfish 主题，优点是文档很全，而且文档支持中文，提供了多种主页布局方式和网站配色。我最喜欢的是‘Avocado’这个配色的深色模式，看起来很舒服。\n不建议使用 Blowfish-Tools 工具安装，除非你对 Hugo 框架很熟悉，知道每一个步骤都是在干什么，否则，不推荐使用它。\n推荐使用 使用 Git 子模块安装 主题。\ngit submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 下载好之后，目录 themes 中就会多出来一个 blowfish 的目录，里边就是主题的默认内容。\n设置主题的配置文件 # 在根目录中，删除 Hugo 自动生成的 hugo.toml 文件。从目录 themes/blowfish/config/_default 中复制 *.toml 文件，粘贴到 config/_default/ 目录中。Hugo 可以将这些配置统一放在一个 toml 文件中，也可以分多个 toml 文件，便于更好的管理。\n接着一定要设置 config/_default/hugo.toml 中的 theme = \u0026quot;blowfish\u0026quot;，这样才能使用对用的主题。\n关于 Blowfish 主题如何配置和使用，官网介绍已经很全了，详细内容请查看官网文档：Blowfish 文档 。\n接下来只说几个重要的点：\n自定义网站图标 # Blowfish 主题默认的网站图标是一条蓝色的小河豚，我们可以自定义自己喜欢的图标做自己的网站图标。\n网站图标资源的位置在 static/ 文件夹中，名称必须和下面的名称一样。如果使用了favicon.io，那么下载下来解压后的文件名和下面是完全一致的，直接拷贝到 static/ 中即可。\nstatic/ ├─ android-chrome-192x192.png ├─ android-chrome-512x512.png ├─ apple-touch-icon.png ├─ favicon-16x16.png ├─ favicon-32x32.png ├─ favicon.ico └─ site.webmanifest 用 Hugo 创建文章 # 用 Hugo 创建一篇文章的命令是：\nhugo new xxx.md 用这个命令创建的 Markdown 文件会套用 archetypes 文件夹中的 front matter 模版，在空白处用 Markdown 写入内容。\n其中，draft = true 代表这篇文章是一个草稿，Hugo 生成页面不会显示草稿，要在主页显示此文章，可以设置 draft = false ，或者直接删掉这行。\n本地调试和预览 # 在发布到网站前，我们可以在本地预览网站的内容和效果，运行命令：\nhugo server 启动完成后，在浏览器输入 http//localhost:1313/ 可以实时预览生成的网站效果。\n使用上边的命令后，会发现文档上 draft = false 的文章不会显示，需要修改启动参数：\nhugo server -D 这样，草稿文章内容也会显示了。\n使用 GitHub Page 构建网站 # Hugo 提供非常详尽的 GitHub Pages 部署指引。这里对部署过程做简单梳理：\n在 ./.github/workflows/ 中放入 hugo.yml；\n将本地网站同步到 GitHub 同名仓库；\n在仓库设置 Settings -\u0026gt; Pages 中选择 Build and deployment 选择 GitHub Actions,将 Hugo 推送到 GitHub 上时,便会自动构建网页。\n完成以上步骤，你便可以通过 https://\u0026lt;your-github-id\u0026gt;.github.io 访问自己的个人博客。\n","date":"2024-6-28","externalUrl":null,"permalink":"/posts/build-blog/","section":"Posts","summary":"","title":"利用 GitHub Pages + Hugo 搭建个人博客","type":"posts"},{"content":"","date":"2024-6-28","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%AB%99/","section":"Tags","summary":"","title":"网站","type":"tags"},{"content":" 一直在想，是不是做一个博客比较好，抽点时间，记录些东西也挺好。\n纠结了两天用哪个组件建立博客，看了 hexo、hugo 和 astro 三个组件，尝试了 hexo 和 hugo，最终还是决定用 hugo。\n其实在很早之前，我就想做一个自己的博客，记录下自己的学习和成长，哪怕不是技术相关的也好。人生的成长，技术只是一个方面，更多的还有思想、情商。技术力是很重要的一个方面，但也仅仅只是一个方面。\n小时候希望自己长大了当个科学家（貌似当时的教育，大家都是科学家）， 只知道学习，但是还学不好。考了个一般的本科，学了个一般的专业（土木🐶），找了个一般的工作。本想着在自己的专业做出点名堂，谁知道被社会狠狠的毒打。对于工地上的风气，我是深恶痛绝，再加上每周只能歇一天，我果断选择了转行，脱离了苦海。\n我也是挺佩服自己的，什么都不懂，就敢转行，想想年起的自己真的是很有胆量。于是听了同学减建议，背着书包，离开家乡，跑到帝都，租个破房，孤身一人，开始闯荡。一路从 JAVA 干到 大数据，甚至做过前端 VUE 项目，差点把自己干成全栈。熬了这么多年，目前只是一个不合格的组长（2024年）。\n庆幸自己转行的比较早，就目前这个形式，土木感觉都成夕阳行业了，IT 也不再是风口浪尖了，后续给人吹牛，还可以说自己是在浪尖待过那么一段时间的人呢，哈哈。\n趁自己还没老，抓紧做自己喜欢的事情。及时行乐，何尝不是一种洒脱。趁现在，从构建一个博客开始，加油，做自己想做的事情吧。\n","date":"2024-6-25","externalUrl":null,"permalink":"/posts/beginning/","section":"Posts","summary":"","title":"开篇","type":"posts"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/tags/%E9%9A%8F%E6%83%B3/","section":"Tags","summary":"","title":"随想","type":"tags"},{"content":"","date":"2024-6-25","externalUrl":null,"permalink":"/categories/%E6%9D%82%E9%A1%B9/","section":"Categories","summary":"","title":"杂项","type":"categories"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-1-1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]